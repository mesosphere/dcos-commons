<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">







<head>
<title>SDK Developer Guide</title>
<link rel="stylesheet" type="text/css" media="all" href="./style/gh-basic.css" />
<link rel="shortcut icon" type="image/png" href="https://mesosphere.com/favicon.ico"/>
<!-- The Dropdown library is written by Stephen Morley, licensed CC0 1.0 Universal (Public Domain Dedication)-->
<link rel="stylesheet" type="text/css" media="all" href="./style/Dropdown.css" />
<script src="./style/Dropdown.js"></script>
<style type="text/css">
/* set the background color of menu items */
.dropdown, .dropdown ul { background: #555555; clear: both; }
/* set the background color of active items */
.dropdown li:hover > a, .dropdown li:hover > span, .dropdown li.dropdownOpen > a, .dropdown li.dropdownOpen > span { background: #af87e0; }
/* pad items, set their text color, and fade their background color */
.dropdown a, .dropdown span { padding: 0.25em 0.5em; color: white; transition: background 0.2s; }
/* show '+' on expandable items */
.dropdown span:after { content: " +"; }

/* toc style: remove extra margin between elements */
#markdown-toc ul { margin: 0; }
</style>
</head>

<body>
<div id="wrapper">

<a href=".">
<img style="float: left; margin-bottom: 2em" src="https://mesosphere.com/wp-content/themes/mesosphere/library/images/assets/dcos-sdk-logo.png" width="250" alt="DC/OS Software Development Kit" />
</a>
<img style="float: right" src="https://img.shields.io/badge/Status-Alpha-BF97F0.svg?style=flat-square" alt="Status: Alpha" />

<ul class="dropdown" style="clear: both">
  <li>
    <a href=".">Home</a>
  </li>
  <li>
    <span>Documentation</span>
    <ul>
      
      
      <li><a href="./developer-guide.html">SDK Developer Guide</a></li>
      
      <li><a href="./faq.html">Frequently Asked Questions</a></li>
      
      <li><a href="./glossary.html">Glossary</a></li>
      
      <li><a href="./yaml-reference.html">YAML Reference</a></li>
      
      <li><a href="./swagger-api">REST APIs</a></li>
      <li><a href="./api">Javadoc Reference</a></li>
    </ul>
  </li>
  <li>
    <span>Tutorials</span>
    <ul>
      
      
      <li><a href="./tutorials/automatic-repair.html">Automatic Repair</a></li>
      
      <li><a href="./tutorials/data-store-tutorial.html">Data Store Tutorial</a></li>
      
      <li><a href="./tutorials/kafka-tutorial.html">Kafka Tutorial</a></li>
      
      <li><a href="./tutorials/quick-start-java.html">Quick Start (Java)</a></li>
      
    </ul>
  </li>
  <li>
    <span>Services</span>
    <ul>
      
      
      
      
      <li>
        
        <span>Elastic</span>
        
        <ul>
          
          
          <li><a href="./services/elastic/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="./services/elastic/install.html">Install and Customize</a></li>
          
          <li><a href="./services/elastic/upgrade.html">Upgrade</a></li>
          
          <li><a href="./services/elastic/uninstall.html">Uninstall</a></li>
          
          <li><a href="./services/elastic/configure.html">Configuring</a></li>
          
          <li><a href="./services/elastic/connecting.html">Connecting Clients</a></li>
          
          <li><a href="./services/elastic/backup_restore.html">Backup and Restore</a></li>
          
          <li><a href="./services/elastic/managing.html">Managing</a></li>
          
          <li><a href="./services/elastic/api-reference.html">API Reference</a></li>
          
          <li><a href="./services/elastic/troubleshooting.html">Troubleshooting</a></li>
          
          <li><a href="./services/elastic/version_policy.html">Version Policy</a></li>
          
          <li><a href="./services/elastic/limitations.html">Limitations</a></li>
          
        </ul>
      </li>
      
      <li>
        
        <span>HDFS</span>
        
        <ul>
          
          
          <li><a href="./services/hdfs/install.html">Install and Customize</a></li>
          
          <li><a href="./services/hdfs/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="./services/hdfs/uninstall.html">Uninstall</a></li>
          
          <li><a href="./services/hdfs/configure.html">Configuring</a></li>
          
          <li><a href="./services/hdfs/connecting-clients.html">Connecting Clients</a></li>
          
          <li><a href="./services/hdfs/managing.html">Managing</a></li>
          
          <li><a href="./services/hdfs/api-reference.html">API Reference</a></li>
          
          <li><a href="./services/hdfs/troubleshooting.html">Troubleshooting</a></li>
          
        </ul>
      </li>
      
      <li>
        
        <span>Kafka</span>
        
        <ul>
          
          
          <li><a href="./services/kafka/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="./services/kafka/install-and-customize.html">Install and Customize</a></li>
          
          <li><a href="./services/kafka/uninstall.html">Uninstall</a></li>
          
          <li><a href="./services/kafka/configure.html">Configure</a></li>
          
          <li><a href="./services/kafka/connecting-clients.html">Connecting Clients</a></li>
          
          <li><a href="./services/kafka/managing.html">Managing</a></li>
          
          <li><a href="./services/kafka/api-reference.html">API Reference</a></li>
          
          <li><a href="./services/kafka/troubleshooting.html">Troubleshooting</a></li>
          
          <li><a href="./services/kafka/version-policy.html">Version Policy</a></li>
          
          <li><a href="./services/kafka/limitations.html">Limitations</a></li>
          
        </ul>
      </li>
      
    </ul>
  </li>
  <li><a href="https://github.com/mesosphere/dcos-commons/blob/master/CONTRIBUTING.md">Contributing</a></li>
  <li><a href="http://chat.dcos.io" target="_blank">Slack</a></li>
</ul>
<h1>SDK Developer Guide</h1>
<div id="content">
<!-- Generate TOC. Both lines are required: https://kramdown.gettalong.org/converter/html.html#toc -->
<ul id="markdown-toc">
  <li><a href="#dcos-component-overview" id="markdown-toc-dcos-component-overview">DC/OS Component Overview</a>    <ul>
      <li><a href="#mesos" id="markdown-toc-mesos">Mesos</a></li>
      <li><a href="#marathon" id="markdown-toc-marathon">Marathon</a></li>
      <li><a href="#universe" id="markdown-toc-universe">Universe</a></li>
      <li><a href="#zookeeper" id="markdown-toc-zookeeper">Zookeeper</a></li>
    </ul>
  </li>
  <li><a href="#getting-started" id="markdown-toc-getting-started">Getting Started</a></li>
  <li><a href="#introduction-to-dcos-service-definitions" id="markdown-toc-introduction-to-dcos-service-definitions">Introduction to DC/OS Service Definitions</a>    <ul>
      <li><a href="#servicespec" id="markdown-toc-servicespec">ServiceSpec</a>        <ul>
          <li><a href="#annotated-example-of-a-servicespec" id="markdown-toc-annotated-example-of-a-servicespec">Annotated Example of a <code class="highlighter-rouge">ServiceSpec</code></a></li>
          <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
        </ul>
      </li>
      <li><a href="#plans" id="markdown-toc-plans">Plans</a></li>
      <li><a href="#packaging" id="markdown-toc-packaging">Packaging</a>        <ul>
          <li><a href="#universe-package-files-at-a-glance" id="markdown-toc-universe-package-files-at-a-glance">Universe Package Files At-a-Glance</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#basic-operations" id="markdown-toc-basic-operations">Basic Operations</a>    <ul>
      <li><a href="#defining-a-target-configuration" id="markdown-toc-defining-a-target-configuration">Defining a Target Configuration</a></li>
      <li><a href="#plan-execution" id="markdown-toc-plan-execution">Plan Execution</a>        <ul>
          <li><a href="#plan-acceptance-or-rejection" id="markdown-toc-plan-acceptance-or-rejection">Plan Acceptance or Rejection</a></li>
          <li><a href="#executing-a-plan" id="markdown-toc-executing-a-plan">Executing a Plan</a></li>
          <li><a href="#install" id="markdown-toc-install">Install</a></li>
          <li><a href="#update" id="markdown-toc-update">Update</a>            <ul>
              <li><a href="#vertical-scale-example" id="markdown-toc-vertical-scale-example">Vertical Scale Example</a></li>
              <li><a href="#horizontal-scale-example" id="markdown-toc-horizontal-scale-example">Horizontal Scale Example</a></li>
            </ul>
          </li>
          <li><a href="#rollback" id="markdown-toc-rollback">Rollback</a></li>
          <li><a href="#software-upgrade" id="markdown-toc-software-upgrade">Software Upgrade</a></li>
          <li><a href="#api" id="markdown-toc-api">API</a>            <ul>
              <li><a href="#view" id="markdown-toc-view">View</a></li>
              <li><a href="#interrupt" id="markdown-toc-interrupt">Interrupt</a></li>
              <li><a href="#continue" id="markdown-toc-continue">Continue</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#service-discovery" id="markdown-toc-service-discovery">Service Discovery</a>    <ul>
      <li><a href="#mesos-dns" id="markdown-toc-mesos-dns"><a href="https://github.com/mesosphere/mesos-dns">Mesos-DNS</a></a></li>
      <li><a href="#vip" id="markdown-toc-vip"><a href="https://github.com/dcos/minuteman">VIP</a></a></li>
    </ul>
  </li>
  <li><a href="#testing" id="markdown-toc-testing">Testing</a>    <ul>
      <li><a href="#unit-tests" id="markdown-toc-unit-tests">Unit tests</a></li>
      <li><a href="#integration-tests" id="markdown-toc-integration-tests">Integration tests</a></li>
    </ul>
  </li>
  <li><a href="#advanced-dcos-service-definition" id="markdown-toc-advanced-dcos-service-definition">Advanced DC/OS Service Definition</a>    <ul>
      <li><a href="#servicespec-yaml" id="markdown-toc-servicespec-yaml"><code class="highlighter-rouge">ServiceSpec</code> (YAML)</a>        <ul>
          <li><a href="#containers" id="markdown-toc-containers">Containers</a></li>
          <li><a href="#placement-rules" id="markdown-toc-placement-rules">Placement Rules</a></li>
          <li><a href="#resource-sets" id="markdown-toc-resource-sets">Resource Sets</a></li>
          <li><a href="#sidecar-plans" id="markdown-toc-sidecar-plans">Sidecar Plans</a></li>
          <li><a href="#uris" id="markdown-toc-uris">URIs</a></li>
          <li><a href="#configuration-templates" id="markdown-toc-configuration-templates">Configuration Templates</a></li>
          <li><a href="#task-environment" id="markdown-toc-task-environment">Task Environment</a></li>
          <li><a href="#task-bootstrap" id="markdown-toc-task-bootstrap">Task Bootstrap</a></li>
          <li><a href="#health-checks" id="markdown-toc-health-checks">Health Checks</a></li>
          <li><a href="#readiness-checks" id="markdown-toc-readiness-checks">Readiness Checks</a></li>
          <li><a href="#volumes" id="markdown-toc-volumes">Volumes</a></li>
          <li><a href="#proxy" id="markdown-toc-proxy">Proxy</a></li>
          <li><a href="#proxy-fallback" id="markdown-toc-proxy-fallback">Proxy Fallback</a></li>
        </ul>
      </li>
      <li><a href="#servicespec-java" id="markdown-toc-servicespec-java"><code class="highlighter-rouge">ServiceSpec</code> (Java)</a>        <ul>
          <li><a href="#placement-rules-1" id="markdown-toc-placement-rules-1">Placement Rules</a></li>
        </ul>
      </li>
      <li><a href="#custom-plans-java" id="markdown-toc-custom-plans-java">Custom Plans (Java)</a>        <ul>
          <li><a href="#internals" id="markdown-toc-internals">Internals</a></li>
          <li><a href="#strategy" id="markdown-toc-strategy">Strategy</a></li>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<!--  disable mustache templating in this file: retain templated examples as-is -->

<p>This developer guide explains how to create a stateful DC/OS service using the DC/OS SDK. The DC/OS SDK is a collection of tools, libraries, and documentation that facilitates the creation of DC/OS services.</p>

<h1 id="dcos-component-overview">DC/OS Component Overview</h1>

<p>The four major components are Mesos, Marathon, Universe, and Zookeeper. These components have different responsibilities and must cooperate. To develop a service, you should have a high level understanding of these components and their responsibilities.</p>

<h2 id="mesos">Mesos</h2>

<p>DC/OS is modeled on an operating system with Mesos as its kernel. Mesos provides an abstraction to enable consumption of the resources a datacenter provides.  In a typical case, these resources are CPU, memory, disk space, and ports. Tasks are launched in the datacenter and consume particular subsets of resources. The programs that can receive resource offers and launch tasks that consume are called <strong>frameworks</strong>. The component of a framework that receives offers and launches tasks is called the <strong>scheduler</strong>.</p>

<p>Mesos determines which frameworks should be offered resources at any given time. It sends update events regarding the status of those tasks. These events include <em>staging, running, failed</em>,* *etc.  To learn more about Mesos, consult the  “<a href="https://open.mesosphere.com/advanced-course/">Mesos Advanced Course</a>”.</p>

<h2 id="marathon">Marathon</h2>

<p>The scheduler is the  entity that can launch tasks on DC/OS.  The role of Marathon is to launch Mesos tasks and to restart them if they crash.  In the context of the SDK, the tasks that Marathon launches are schedulers.  These schedulers in turn launch the tasks necessary for the operation of a DC/OS service. Therefore, if a scheduler crashes, it is Marathon’s responsibility to restart the scheduler.</p>

<p>If we consider Mesos to be DC/OS’ kernel, then Marathon is its init system. It launches and keeps up the software that should be running on the operating system.</p>

<p>Marathon is itself a Mesos framework. Some of the tasks it launches are the schedulers written with the SDK described here. Use an application or pod definition to tell. Application and pods definitions are declarative JSON representations of a task or tasks that Marathon should run.To learn more, consult the <a href="https://mesosphere.github.io/marathon/">Marathon documentation</a>.</p>

<h2 id="universe">Universe</h2>

<p>A package specification provides a uniform way to define Marathon applications.  Those packages are stored in the Universe so end-users can easily install these DC/OS services in their datacenters..</p>

<p>Every DC/OS service must provide a package definition in the format expected by the Universe. <a href="https://github.com/mesosphere/universe">Learn more about creating Universe packages</a>.</p>

<h2 id="zookeeper">Zookeeper</h2>

<p>Several DC/OS components, including Mesos and Marathon, require a persistent metadata store. Zookeeper fulfills this role for those components as well as for services written using the SDK. As noted previously, any service written using the SDK is a Mesos scheduler. In order to accurately communicate with Mesos, every scheduler must keep a record of the the state of its tasks. Zookeeper provides persistent storage for this information.</p>

<p>Although all SDK services written today store metadata in Zookeeper, this is an implementation detail. The <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/config/ConfigStore.java">ConfigStore</a> and <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/state/StateStore.java">StateStore</a> interfaces are generic and unopinionated about the backing persistent metadata store.</p>

<p>They store the desired configuration of a service and all relevant information regarding Mesos tasks, respectively, but the precise format or location of the underlying data may be customized.  For example, the data may be stored in Zookeeper, but in a different format, or the data may be stored in a different persistent storage like etcd.  The defaults should be reasonable for most developers, however. Support for optional customization via drop-in replacement is a common pattern throughout the SDK.</p>

<h1 id="getting-started">Getting Started</h1>

<ol>
  <li>
    <p>Create your framework.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>./new-service.sh frameworks/myframework
<span class="gp">$ </span><span class="nb">cd </span>frameworks/myframework
</code></pre>
    </div>

    <p><code class="highlighter-rouge">new-service.sh</code> creates a skeleton framework.  You will extend
this skeleton.</p>
  </li>
  <li>
    <p>View <code class="highlighter-rouge">svc.yml</code>.</p>

    <p>Take a look at <code class="highlighter-rouge">src/main/dist/svc.yml</code>.  This is the YAML file that
defines your framework.  You will be editing this file.</p>
  </li>
  <li>
    <p>View <code class="highlighter-rouge">Main.java</code>.</p>

    <p>Take a look at
<code class="highlighter-rouge">src/main/java/com/mesosphere/sdk/myframework/scheduler/Main.java</code>.
This is the main method for your scheduler, which will be run in
DC/OS via Marathon.  It reads <code class="highlighter-rouge">svc.yml</code>, which defines its
behavior.  If you need any advanced functionality not provided by
YAML, such as complex deployment plans, you will write it here.</p>
  </li>
  <li>
    <p>Build a <a href="#packaging">package</a>.</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>./build.sh aws
</code></pre>
    </div>

    <p>You will deploy your framework to DC/OS as a
<a href="#packaging">package</a>.  <code class="highlighter-rouge">build.sh</code> creates this package.</p>
  </li>
  <li>
    <p>Install your package.</p>

    <p><code class="highlighter-rouge">build.sh</code> prints instructions for installing the package.  They
will look something like this:</p>

    <div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dcos package repo remove myframework-aws
<span class="gp">$ </span>dcos package repo add --index<span class="o">=</span>0 myframework-aws https://mybucket.s3.amazonaws.com/stub-universe-myframework.zip
<span class="gp">$ </span>dcos package install --yes myframework
</code></pre>
    </div>

    <p>Navigate to the DC/OS Services UI to view the deployment.</p>
  </li>
  <li>
    <p>Uninstall your package.</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>$ dcos package uninstall myframework
$ dcos node ssh --master-proxy --leader "docker run mesosphere/janitor /janitor.py -r myframework-role -p myframework-principal -z dcos-service-myframework
</code></pre>
    </div>

    <p>The second command above runs the <strong>janitor</strong> script.  The janitor
script runs inside the DC/OS cluster, cleaning up Zookeeper state
and resource reservations made by a framework.  DC/OS will soon
support uninstall hooks so this can happen automatically, but for
now, you must manually run the janitor script as shown above.</p>
  </li>
</ol>

<h1 id="introduction-to-dcos-service-definitions">Introduction to DC/OS Service Definitions</h1>

<p>At the highest level of abstraction, a DC/OS service breaks down into <em>which</em> tasks to launch and <em>how</em> to launch them. The <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/specification/ServiceSpec.java">ServiceSpec</a> defines what a service is and <a href="#plans">Plan</a>[s] define how to control it in deployment, update, and failure scenarios. The <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/specification/ServiceSpec.java">ServiceSpec</a> and <a href="#plans">Plan</a>[s] are <a href="#packaging">packaged</a> so that the service can be deployed on a DC/OS cluster from Universe.</p>

<p><a name="service-spec"></a></p>
<h2 id="servicespec">ServiceSpec</h2>

<p>There are two ways to generate a valid <code class="highlighter-rouge">ServiceSpec</code>: creating a YAML file or writing Java code. Both produce a valid implementation of the Java <code class="highlighter-rouge">ServiceSpec</code> interface.  A <code class="highlighter-rouge">ServiceSpec</code> may be used to launch one or more instances of the same service within a DC/OS cluster.</p>

<p>For example, one could write a <code class="highlighter-rouge">ServiceSpec</code> that describes a DC/OS service that deploys a Kafka cluster. One could then install one or more instances of a Kafka cluster in a DC/OS cluster. A <code class="highlighter-rouge">ServiceSpec</code> is in this sense similar to a class definition, which may be used to create many objects that are instances of the class.</p>

<h3 id="annotated-example-of-a-servicespec">Annotated Example of a <code class="highlighter-rouge">ServiceSpec</code></h3>

<p>This simple YAML definition of a DC/OS service that prints “hello world” to stdout in a container sandbox every 1000 seconds.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">scheduler</span><span class="pi">:</span>
  <span class="s">principal</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world-principal"</span>
  <span class="s">api-port</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">PORT_API</span><span class="pi">}}</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello-world-pod</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">hello-world-task</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">world</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">512</span>
</code></pre>
</div>

<ul>
  <li>
    <p><strong>name</strong>:  This is the name of an instance of a DC/OS service. No two instances of any service may have the same name in the same cluster.</p>
  </li>
  <li>
    <p><strong>scheduler</strong>: The Scheduler manages the service and keeps it running. This section contains settings which apply to the Scheduler. The <code class="highlighter-rouge">scheduler</code> section may be omitted to use reasonable defaults for all of these settings.</p>

    <ul>
      <li>
        <p><strong>principal</strong>: This is the Mesos principal used when registering the framework. In secure Enterprise clusters, this principal must have the necessary permission to perform the actions of a scheduler. This setting may be omitted in which case it defaults to <code class="highlighter-rouge">&lt;svcname&gt;-principal</code>.</p>
      </li>
      <li>
        <p><strong>api-port</strong>: By default, a DC/OS service written with the SDK provides a number of REST API endpoints that may be used to examine the state of a service as well as alter its operation. In order to expose the endpoints, you must define on which port the HTTP server providing those endpoints should listen. You can also add custom service-specific endpoints.  Learn more in the <a href="#define-target-config">Defining a Target Configuration section</a>. This setting may be omitted in which case it defaults to the <code class="highlighter-rouge">PORT_API</code> envvar provided by Marathon.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Pods</strong>: A pod can be defined most simply as a set of tasks.</p>
  </li>
  <li>
    <p><strong>hello-world-pod</strong>: This is the name of a type of a pod. You can choose any name for a pod type  In this example, we have one kind of pod defined and its name is <code class="highlighter-rouge">hello-world-pod</code>.</p>
  </li>
  <li>
    <p><strong>count</strong>: The number of instances of the pod.</p>
  </li>
  <li>
    <p><strong>tasks</strong>: The list of tasks in the pod.</p>
  </li>
  <li>
    <p><strong>hello-world-task</strong>: In this example, the single pod definition is composed of a single task. The name of this task is “hello-world-task”.</p>
  </li>
  <li>
    <p><strong>goal</strong>: Every task must have a goal state. There are two possible goal states: <code class="highlighter-rouge">RUNNING</code> and <code class="highlighter-rouge">FINISHED</code>. <code class="highlighter-rouge">RUNNING</code> indicates that a Task should always be running, so if it exits, it should be restarted. <code class="highlighter-rouge">FINISHED</code> indicates that if a task finishes successfully it does not need to be restarted.</p>
  </li>
  <li>
    <p><strong>cmd</strong>: The command to run to start a task. Here, the task will print “hello world” to stdout and sleep for 1000 seconds. Because its goal state is <code class="highlighter-rouge">RUNNING</code>, it will be started again upon exit.</p>
  </li>
  <li>
    <p><strong>cpus</strong>: This entry defines how many CPUs will be allocated to the task’s container.  For discussion of how resources are isolated and allocate <a href="http://mesos.apache.org/documentation/latest/containerizer/">see the Mesos documentation here</a>.</p>
  </li>
  <li>
    <p><strong>memory</strong>: This entry defines how much memory will be allocated to the task’s container.</p>
  </li>
</ul>

<h3 id="summary">Summary</h3>

<p>A set of pods defines <em>what</em> your service is. Pods are composed of task definitions.</p>

<p>In the example, we have only defined types of pods and tasks. When the service is deployed and instantiated into instances of these types, we get a Mesos task like the following:</p>

<table>
  <tr>
    <td>Task Name</td>
    <td>Task ID</td>
    <td>Task Status</td>
  </tr>
  <tr>
    <td>hello-world-pod-0-hello-world-task</td>
    <td>hello-world-pod-0-hello-world-task__c111c97e-7236-4fea-b06f-0216c93b853b</td>
    <td>TASK_RUNNING</td>
  </tr>
</table>

<p>Since a single pod instance was requested via the <em>count</em> element, only a single task was launched. Its index (0) was injected into the task name and ID. If we had defined a count higher than one, more tasks with incremental indices would have been launched.</p>

<p><a name="plans"></a></p>
<h2 id="plans">Plans</h2>

<p>In the simple example above, it is obvious <em>how</em> to deploy this service.  It consists of a single task that launches . For more complex services with multiple pods, the SDK allows the definition of <em>plans</em> to orchestrate the deployment of tasks.</p>

<p>The example below defines a service with two types of pods, each of which deploys two instances.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello-pod</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">2</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">hello-task</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">512</span>
  <span class="s">world-pod</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">2</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">world-task</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">world</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">512</span>
</code></pre>
</div>

<p>There are a number of possible deployment strategies: In parallel or serially, and with or without one pod type waiting for the other’s successful deployment before deploying.</p>

<p>By default, the SDK will deploy all instances of pods serially.  In the example above, the default deployment order would be:</p>

<ol>
  <li>
    <p>hello-pod-0-hello-task</p>
  </li>
  <li>
    <p>hello-pod-1-hello-task</p>
  </li>
  <li>
    <p>world-pod-0-world-task</p>
  </li>
  <li>
    <p>world-pod-1-world-task</p>
  </li>
</ol>

<p>Each pod’s task must reach its goal of <code class="highlighter-rouge">RUNNING</code> before the next pod is launched. This is the simplest and safest possible approach as a default deployment strategy.</p>

<p>However, this default deployment strategy does not provide the flexibility you need to write rich services. The SDK therefore also allows you to define <em>plans</em> that orchestrate task deployment.</p>

<p>In this section we focus on using plans to define the initial deployment of a service. However, you can also use plans to orchestrate configuration updates, software upgrades, and recovery from complex, service-specific failure scenarios.</p>

<p>As an example, let’s consider the scenario where we wish to deploy the hello-pods in parallel, wait for them to reach a <code class="highlighter-rouge">RUNNING</code> state and then deploy the world-pods serially.  We could amend our YAML file to look like the following:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello-pod</span><span class="pi">:</span>
  <span class="s">count</span><span class="pi">:</span> <span class="s">2</span>
  <span class="s">tasks</span><span class="pi">:</span>
    <span class="s">hello-task</span><span class="pi">:</span>
      <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
      <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
      <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
      <span class="s">memory</span><span class="pi">:</span> <span class="s">512</span>
  <span class="s">world-pod</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">2</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">hello-task</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">world</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">512</span>
<span class="s">plans</span><span class="pi">:</span>
  <span class="s">deploy</span><span class="pi">:</span>
    <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
    <span class="s">phases</span><span class="pi">:</span>
      <span class="s">hello-phase</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">parallel</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">hello-pod</span>
      <span class="s">world-phase</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">world-pod</span>
</code></pre>
</div>

<p>A plan is a simple three layer hierarchical structure.  A plan is composed of phases, which in turn are composed of steps.  Each layer may define a strategy for how to deploy its constituent elements. The strategy at the highest layer defines how to deploy phases. Each phase’s strategy defines how to deploy steps. The default strategy if none is specified is serial.</p>

<p><img src="img/dev-guide-plans-vs-services.png" alt="plans vs services" /></p>

<p>A phase encapsulates a pod type and a step encapsulates an instance of a pod.  So in this case we have two phases: hello-phase and world-phase.  They are clearly associated with their particular pod definitions from the ServiceSpec. In the example above, we do not need to specifically define steps to accomplish our deployment strategy goal, so they are omitted.</p>

<p>The hello-phase of the example has two elements: a strategy and a pod.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">plans</span><span class="pi">:</span>
  <span class="s">deploy</span><span class="pi">:</span>
    <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
    <span class="s">phases</span><span class="pi">:</span>
      <span class="s">hello-phase</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">parallel</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">hello-pod</span>
      <span class="s">world-phase</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">world-pod</span>
</code></pre>
</div>

<p>The pod parameter references the pod definition earlier in the <code class="highlighter-rouge">ServiceSpec</code>. The strategy declares how to deploy the instances of the pod. Here, they will be deployed in parallel. The world-phase section is identical, except that its elements will be deployed serially.</p>

<p>The strategy associated with the deployment plan as a whole is serial, so the phases should be deployed one at a time. This dependency graph illustrates the deployment.</p>

<p><img src="img/dev-guide-deployment-steps.png" alt="deployment steps" /></p>

<p>The dependency of the <code class="highlighter-rouge">world-pod</code> phase on the <code class="highlighter-rouge">hello-pod</code> phase serializes those two phases as described at the top level strategy element. Since both <code class="highlighter-rouge">hello</code> steps depend on a the<code class="highlighter-rouge"> hello-pod</code> phase, and not each other, they are executed in parallel. The second <code class="highlighter-rouge">world-pod</code> instance depends on the first, so they are launched serially.</p>

<p>More powerful custom plans can also be written. Consider the case in which a pod requires an initialization step to be run before the main task of a pod is run. One could define the tasks for such a pod as follows:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">2</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">hello-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s">hello-data</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">5000</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">init</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">FINISHED</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./init"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
      <span class="s">main</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./main"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
</code></pre>
</div>

<p>By default a the plan generated from such a service definition would only deploy the <code class="highlighter-rouge">main</code> task because when the <code class="highlighter-rouge">init</code> task should be run is undefined.  In order to run the init task and then the main task for each instance of the <code class="highlighter-rouge">hello</code> pod one could write a plan as follows:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">plans</span><span class="pi">:</span>
  <span class="s">deploy</span><span class="pi">:</span>
    <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
    <span class="s">pod</span><span class="pi">:</span> <span class="s">hello</span>
    <span class="s">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">default</span><span class="pi">:</span> <span class="pi">[[</span><span class="nv">init</span><span class="pi">],</span> <span class="pi">[</span><span class="nv">main</span><span class="pi">]]</span>
</code></pre>
</div>

<p>This plan indicates that by default, every instance of the hello pod should have two steps generated: one representing the <code class="highlighter-rouge">init</code> task and another representing the <code class="highlighter-rouge">main</code> task. The ServiceSpec indicates that two <code class="highlighter-rouge">hello</code> pods should be launched so the following tasks would be launched by steps serially:</p>

<ol>
  <li>hello-0-init</li>
  <li>hello-0-main</li>
  <li>hello-1-init</li>
  <li>hello-1-main</li>
</ol>

<p>Consider the case where the init task should only occur once for the first pod, and all subsequent pods should just launch their <code class="highlighter-rouge">main</code> task. Such a plan could be written as follows:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">plans</span><span class="pi">:</span>
  <span class="s">deploy</span><span class="pi">:</span>
    <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
    <span class="s">pod</span><span class="pi">:</span> <span class="s">hello</span>
    <span class="s">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">0</span><span class="pi">:</span> <span class="pi">[[</span><span class="nv">init</span><span class="pi">],</span> <span class="pi">[</span><span class="nv">main</span><span class="pi">]]</span>
      <span class="pi">-</span> <span class="s">default</span><span class="pi">:</span> <span class="pi">[[</span><span class="nv">main</span><span class="pi">]]</span>
</code></pre>
</div>

<p>This plan would result in steps generating the following tasks:</p>

<ol>
  <li>hello-0-init</li>
  <li>hello-0-main</li>
  <li>hello-1-main</li>
</ol>

<p>You can learn more about the full capabilities of plans <a href="#plan-execution">here</a> and <a href="#custom-plans-java">here</a>.</p>

<p><a name="packaging"></a></p>
<h2 id="packaging">Packaging</h2>

<p>A DC/OS service must provide a package definition in order to be installed on a DC/OS cluster. At a minimum, a package definition is composed of four files: <code class="highlighter-rouge">marathon.json.mustache</code>, <code class="highlighter-rouge">config.json</code>, <code class="highlighter-rouge">resource.json</code>, and <code class="highlighter-rouge">package.json</code>. <a href="https://github.com/mesosphere/dcos-commons/tree/master/frameworks/helloworld/universe">Examples of all these files</a> are provided in the example helloworld DC/OS service.  A detailed explanation of the format and purpose of each of these files is <a href="https://github.com/mesosphere/universe#creating-a-package">available here</a>.</p>

<h3 id="universe-package-files-at-a-glance">Universe Package Files At-a-Glance</h3>

<p>For a fully detailed explanation of service packaging <a href="https://dcos.io/docs/1.8/development/create-package/">see here</a>; below we provide a brief introduction to the required files.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">marathon.json.mustache</code> -   A mustache-templated file that provides a Marathon application definition.  Its mustache elements are rendered by the values present in the config.json and resource.json files.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Resource.json</code> -  A list of URIs of all downloaded elements.This list allows your service to be deployed in datacenters without Internet access.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">command.json</code> - This file contains elements specific to a CLI for your service if you want to provide one.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">package.json</code> - This file contains metadata of interest to the Universe, including the minimum version of DC/OS on which the service may be deployed.</p>
  </li>
</ul>

<p>The SDK provides utilities for building a package definition and deploying it to a DC/OS cluster for development purposes.  An example build.sh script constructs a package and provides instructions for the deployment.  The helloworld framework’s build.sh script provides the following output:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>./build.sh aws
&lt;snip&gt;
Install your package using the following commands:
dcos package repo remove hello-world-aws
dcos package repo add --index<span class="o">=</span>0 hello-world-aws https://infinity-artifacts.s3.amazonaws.com/autodelete7d/hello-world/20161212-160559-ATLFk70vPlo45X4a/stub-universe-hello-world.zip
dcos package install --yes hello-world
</code></pre>
</div>

<p>The build.sh script takes an optional argument of aws or local:</p>

<ul>
  <li><code class="highlighter-rouge">./build.sh aws</code>: The package definition and build artifacts are uploaded to an S3 bucket in AWS. If you would like to override the S3 bucket location where the packages are uploaded, please add S3_BUCKET environment variable with the bucket name. For example:</li>
</ul>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span><span class="nb">export </span><span class="nv">S3_BUCKET</span><span class="o">=</span>my_universe_s3_bucket
</code></pre>
</div>

<ul>
  <li><code class="highlighter-rouge">./build.sh local</code>: The package definition and build artifacts are served by a local HTTP server.</li>
</ul>

<p>Executing the final command, <code class="highlighter-rouge">dcos package install --yes hello-world</code> deploys the service to a DC/OS cluster.</p>

<h1 id="basic-operations">Basic Operations</h1>

<p>You can perform three fundamental operations on any instance of a DC/OS service: install, update, and uninstall.  With the exception of uninstall, they all follow a fundamental design principle.</p>

<p>All services written with the SDK determine what actions to take based on a target configuration they are trying to reach.  The <code class="highlighter-rouge">ServiceSpec</code> defines the target configuration. When installing for the first time, a service is going from nothing to the target configuration. When performing a configuration update, a service is going from the current configuration to the target configuration. A software update is identical to a configuration update except that that the software artifacts to be deployed are changed, not just the configuration. The path a service takes to a new target configuration is always defined by a plan.</p>

<p>The following events occur to select a target configuration and move a service from its current configuration to the target.</p>

<ol>
  <li>
    <p>Define a target configuration</p>

    <p>a. Deploy a Marathon application definition for your service’s scheduler</p>

    <p>b. The scheduler renders the <code class="highlighter-rouge">ServiceSpec</code> and Plan definitions in the service’s YAML definition.</p>
  </li>
  <li>
    <p>Plan Execution</p>

    <p>a. The scheduler compares previous and current <code class="highlighter-rouge">ServiceSpec</code>s:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>i. Validate the `ServiceSpec`

ii. Determine scenario (install, update or no change)
</code></pre>
    </div>

    <p>b. The plan is chosen and executed</p>
  </li>
</ol>

<p>These steps are discussed in more detail below.</p>

<p><a name="define-target-config"></a></p>

<h2 id="defining-a-target-configuration">Defining a Target Configuration</h2>

<p>We previously described how a DC/OS service’s scheduler is a Marathon application.  Marathon applications define a particular declarative application definition, and DC/OS services constructed with the SDK define another, the <code class="highlighter-rouge">ServiceSpec</code>s and plans.</p>

<p>This nested structure of declarative interfaces requires two layers of template rendering. First, the Marathon application definition must be rendered at initial install time from the combination of the marathon.json.mustache, config.json, and resource.json files. Then, the service’s YAML template is rendered using the environment variables presented to the scheduler. Let’s walk through the <a href="https://github.com/mesosphere/dcos-commons/tree/master/frameworks/helloworld">checked-in helloworld example</a>.  Pay particular attention to the templated values surrounded in curly braces, as in <code class="highlighter-rouge"><span class="p">{</span><span class="err">{value</span><span class="p">}</span><span class="err">}</span></code>.</p>

<p>helloworld has a <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/universe/marathon.json.mustache">marathon.json.mustache template</a> which, in part, looks as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"FRAMEWORK_NAME"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{service.name}}"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"HELLO_COUNT"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{hello.count}}"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"HELLO_CPUS"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{hello.cpus}}"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"{{resource.assets.uris.scheduler-zip}}"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nt">"portDefinitions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nt">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
            </span><span class="nt">"protocol"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tcp"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"api"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"labels"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">"VIP_0"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/api.{{service.name}}:80"</span><span class="w"> </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>The <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/universe/config.json">config.json</a> file is in part:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"object"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"properties"</span><span class="p">:{</span><span class="w">
        </span><span class="nt">"service"</span><span class="p">:{</span><span class="w">
            </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"object"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DC/OS service configuration properties"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"properties"</span><span class="p">:{</span><span class="w">
                </span><span class="nt">"name"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="nt">"description"</span><span class="p">:</span><span class="s2">"The name of the service instance"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"string"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"default"</span><span class="p">:</span><span class="s2">"hello-world"</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nt">"hello"</span><span class="p">:{</span><span class="w">
            </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"object"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"description"</span><span class="p">:</span><span class="s2">"Hello Pod configuration properties"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"properties"</span><span class="p">:{</span><span class="w">
                </span><span class="nt">"cpus"</span><span class="p">:{</span><span class="w">
                    </span><span class="nt">"description"</span><span class="p">:</span><span class="s2">"Hello Pod cpu requirements"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"number"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"default"</span><span class="p">:</span><span class="mf">0.1</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="nt">"count"</span><span class="p">:{</span><span class="w">
                    </span><span class="nt">"description"</span><span class="p">:</span><span class="s2">"Number of Hello Pods to run"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"type"</span><span class="p">:</span><span class="s2">"integer"</span><span class="p">,</span><span class="w">
                    </span><span class="nt">"default"</span><span class="p">:</span><span class="mi">1</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>The <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/universe/resource.json">resource.json</a> file is in part:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"assets"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"scheduler-zip"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{artifact-dir}}/hello-world-scheduler.zip"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>The <code class="highlighter-rouge">marathon.json.mustache</code> template pulls values from <code class="highlighter-rouge">config.json</code> and <code class="highlighter-rouge">resource.json</code> and creates an initial Marathon application definition. This application definition can be deployed on Marathon, which installs a DC/OS service’s scheduler. You can <a href="https://docs.mesosphere.com/latest/usage/managing-services/config/">override the initial config.json values when installing via the command line</a>.</p>

<p><strong>Important:</strong> The environment variable field of the Marathon application definition defines values specific to the helloworld service.</p>

<p>The following is the typical flow of configuration values as represented by environment variables:</p>

<p><img src="img/dev-guide-configuration-values-across-files.png" alt="configuration values across files" /></p>

<p>Once Marathon deploys your scheduler, the service’s YAML specification can be rendered by the environment variables you provided. The helloworld’s service definition is in part:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">// ...</span>
<span class="s">pods</span><span class="pi">:</span>
    <span class="s">hello</span><span class="pi">:</span>
        <span class="s">count</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">HELLO_COUNT</span><span class="pi">}}</span>
        <span class="s">tasks</span><span class="pi">:</span>
            <span class="s">server</span><span class="pi">:</span>
                <span class="s">// ...</span>
                <span class="s">cpus</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">HELLO_CPUS</span><span class="pi">}}</span>
                <span class="s">// ...</span>
</code></pre>
</div>

<p>The port definition in <code class="highlighter-rouge">marathon.json.mustache</code> makes the <code class="highlighter-rouge">PORT0</code> environment variables available to the scheduler. The <code class="highlighter-rouge">HELLO_COUNT</code> and <code class="highlighter-rouge">HELLO_CPUS</code> environment variables are provided by the env field of the Marathon application definition, which is provided by the rendered <code class="highlighter-rouge">marathon.json.mustache</code> template.</p>

<p><a name="rendered-spec"></a>
The final rendered <code class="highlighter-rouge">ServiceSpec</code> is:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
</code></pre>
</div>

<p><a name="plan-execution"></a></p>
<h2 id="plan-execution">Plan Execution</h2>

<h3 id="plan-acceptance-or-rejection">Plan Acceptance or Rejection</h3>

<p>Once a proposed target configuration has been defined in the form of a <code class="highlighter-rouge">ServiceSpec</code>, and, optionally, a deployment plan, the scheduler must decide  what course of action to take. At the outset, a scheduler may choose to accept or reject a proposed target configuration. When a scheduler rejections a proposed target configuration the target configuration does  not change and the previous target configuration remains the target. The scheduler may reject a target configuration because it is malformed, or violates a business logic or other constraint.</p>

<h3 id="executing-a-plan">Executing a Plan</h3>

<p>Once a proposed target configuration is accepted as the target configuration, the scheduler must determine which plan to execute to reach the target. By default, if no overriding deployment plan is provided, the pods defined in the <code class="highlighter-rouge">ServiceSpec</code> will be rolled out serially.</p>

<p>There are two fundamental plan execution scenarios: <strong>install</strong> and <strong>update</strong>.  Let’s first walk through the deployment of the <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/src/main/dist/svc.yml">hello world service</a> in the install case.</p>

<h3 id="install">Install</h3>

<p>Recall the <a href="#rendered-spec">rendered <code class="highlighter-rouge">ServiceSpec</code> from above</a>. A single pod containing a single task is defined generating the following plan:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"phases"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
        </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"8ee5b023-066e-4ef7-a2c9-5fdfc00a50e5"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"steps"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
            </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2e3dde39-3ea3-408b-8e00-3346bef93054"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello-0:[server]"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DefaultStep: 'hello-0:[server]' has status: 'COMPLETE'."</span><span class="w">
        </span><span class="p">}],</span><span class="w">
        </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
    </span><span class="p">}],</span><span class="w">
    </span><span class="nt">"errors"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
    </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>Each pod is deployed with a phase, so we have a single phase named after the pod “hello”.  Each instance of a pod is deployed with a step within that phase. Since there is a single pod instance, we have a single step named “hello-0:[server]”.  The name of the step indicates that it is deploying instance 0 of the pod “hello” with a single task named “server”.</p>

<p>Every element of the plan has an associated status with the following possible values: PENDING, PREPARED, STARTING, COMPLETE, WAITING, and ERROR.</p>

<p>Normally, steps progress through statuses in the following order:</p>

<p>PENDING → PREPARED → STARTING → COMPLETE</p>

<p>The status of a phase or a plan is determined by examination of the step elements.  A step may enter an ERROR state when its construction is malformed or whenever the service author determines it to be appropriate. The WAITING state occurs when the operator of the service indicates that an element should be paused. An operator might want to pause a deployment for a multitude of reasons, including unexpected failures during an update.</p>

<h3 id="update">Update</h3>

<p>In the update case, a scheduler goes from one target configuration to the next. The two examples below show how pods are only restarted to consume new configuration information when that information is relevant to the pod.</p>

<h4 id="vertical-scale-example">Vertical Scale Example</h4>

<p>This example updates the target configuration we defined in the install above. The new target configuration below increases the amount of CPU consumed by the server task.</p>

<p>In the marathon.json.mustache template we defined an environment variable named HELLO_CPUS. Below, we update this value in Marathon from 0.1 to 0.2.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/hello-world"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"HELLO_CPUS"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"HELLO_COUNT"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"SLEEP_DURATION"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1000"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>This will result in restarting the scheduler and re-rendering the <code class="highlighter-rouge">ServiceSpec</code> template. The new template is shown below. Note that the value of <code class="highlighter-rouge">cpus</code> has changed to 0.2.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.2</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
</code></pre>
</div>

<p>A new plan is then generated and execution begins:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"phases"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
        </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ce7bf2e6-857d-4188-a21c-6469c2db92fb"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"steps"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
            </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"c47bf620-9cd7-4bae-b9d0-f56ca00e26ce"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"STARTING"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello-0:[server]"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DefaultStep: 'hello-0:[server]' has status: 'STARTING'."</span><span class="w">
        </span><span class="p">}],</span><span class="w">
        </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"STARTING"</span><span class="w">
    </span><span class="p">}],</span><span class="w">
    </span><span class="nt">"errors"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
    </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"STARTING"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>In this case, we have changed the resources consumed for a running task. In order for it to consume new resources, the task must be killed and restarted consuming more resources. When in the PREPARED state, the task has been killed and will be restarted as soon as appropriate resources are available.</p>

<h4 id="horizontal-scale-example">Horizontal Scale Example</h4>

<p>In the previous example, the change in target configuration affected currently running tasks, so they had to be restarted. In this example, we are changing the number of pod instances to be launched, which should have no effect on currently running pods and therefore will not trigger a restart. The example below changes HELLO_COUNT to 2, adding an additional instance of the hello pod.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/hello-world"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"HELLO_CPUS"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"HELLO_COUNT"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"SLEEP_DURATION"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1000"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>This generates the following Plan:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"phases"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
        </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"25e741c8-a775-481e-9247-d9073002bb3d"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"steps"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
            </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"6780372e-9154-419b-91c4-e0347ca961af"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello-0:[server]"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DefaultStep: 'hello-0:[server]' has status: 'COMPLETE'."</span><span class="w">
        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"6e519f31-8e2d-41ea-955d-85fdd7e1d624"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"PENDING"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hello-1:[server]"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DefaultStep: 'hello-1:[server]' has status: 'PENDING'."</span><span class="w">
        </span><span class="p">}],</span><span class="w">
        </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"STARTING"</span><span class="w">
    </span><span class="p">}],</span><span class="w">
    </span><span class="nt">"errors"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
    </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"STARTING"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>The step associated with instance 0 of the hello pod is never restarted and its step is initialized as COMPLETE.  Another step has been generated for instance 1. Once it has completed, the service will have transitioned from its previous configuration to the new target configuration.</p>

<h3 id="rollback">Rollback</h3>

<p>A special rollback operation is not defined. To roll back a given deployment, deploy the previous configuration as the new target.</p>

<h3 id="software-upgrade">Software Upgrade</h3>

<p>Like rollback, a special software upgrade operation is not defined. To perform an upgrade, just specify a new target configuration. When performing an upgrade, you are probably creating a target configuration that refers to new URIs with new software to launch tasks. This target configuration change is rolled out like any other update.</p>

<h3 id="api">API</h3>

<h4 id="view">View</h4>

<p>You can view the deployment plan via a REST endpoint your scheduler provides. The plans shown in the examples above were accessed by:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/deploy
</code></pre>
</div>

<h4 id="interrupt">Interrupt</h4>

<p>You can interrupt the execution of a plan by issuing a <code class="highlighter-rouge">POST</code> request to the appropriate endpoint:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -X POST -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/deploy/interrupt
</code></pre>
</div>

<p>Interrupting a plan stops any steps that were not being processed from being processed in the future. Any steps that were actively being processed at the time of an interrupt call will continue.</p>

<p>The interrupt may also be issued against a specific phase within the plan:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -X POST -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/deploy/interrupt?phase<span class="o">=</span>data-nodes
</code></pre>
</div>

<p>Interrupting a phase of a plan only stops the steps within that phase, without affecting other phases.</p>

<h4 id="continue">Continue</h4>

<p>Continue plan execution by issuing a <code class="highlighter-rouge">POST</code> request to the continue endpoint:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -X POST -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/deploy/continue
</code></pre>
</div>

<p>Continue may also be issued on a per-phase basis:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -X POST -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/deploy/continue?phase<span class="o">=</span>data-nodes
</code></pre>
</div>

<h1 id="service-discovery">Service Discovery</h1>

<p>There are two service discovery options that are relevant to the SDK: mesos-dns and VIPs.  Mesos-dns provides a stable, predictable address for individual Mesos tasks.  VIPs provide a load balancing mechanism across multiple instances of a class of tasks.</p>

<h2 id="mesos-dns"><a href="https://github.com/mesosphere/mesos-dns">Mesos-DNS</a></h2>

<p>All tasks launched in DC/OS receive a DNS address. It is of the form:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;task-name&gt;.&lt;framework-name&gt;.mesos
</code></pre>
</div>

<p>So a service defined as follows:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.2</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
</code></pre>
</div>

<p>would generate a single task named “hello-0-server”.  The framework’s name is “hello-world”.  The Mesos-DNS address for this task would be “hello-0-server.hello-world.mesos”. Tasks may also specify their own prefixes for the first component of their mesos-dns names using the <code class="highlighter-rouge">discovery</code> section in each task definition. In the following example, two tasks within the same pod share a prefix:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">pod-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.2</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">init</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">FINISHED</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">pod-resources</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">init</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">discovery</span><span class="pi">:</span>
          <span class="s">prefix</span><span class="pi">:</span> <span class="s">hello</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">pod-resources</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">discovery</span><span class="pi">:</span>
          <span class="s">prefix</span><span class="pi">:</span> <span class="s">hello</span>
</code></pre>
</div>

<p>In this case, while running, both the <code class="highlighter-rouge">init</code> and <code class="highlighter-rouge">server</code> tasks would be addressable at “hello-0.hello-world.mesos”, with the “-0” being added automatically to indicate which pod instance to route to. Tasks belonging to different pods may not share the same prefix, and YAML validation will fail if this is found to be the case.</p>

<p><strong>Important:</strong> As with resource sets, only a single process at point in time may use a given prefix, meaning that <code class="highlighter-rouge">init</code> may not run at the same time as <code class="highlighter-rouge">server</code>. A complete service definition would have a deploy plan that ensures this.</p>

<h2 id="vip"><a href="https://github.com/dcos/minuteman">VIP</a></h2>

<p>You can also perform service discovery by defining named virtual IP addresses. VIPs load balance, so every task associated with the same prefix and external port pair will be part of a load-balanced set of tasks.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.2</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">ports</span><span class="pi">:</span>
            <span class="s">http</span><span class="pi">:</span>
                <span class="s">protocol</span><span class="pi">:</span> <span class="s">tcp</span>
                <span class="s">port</span><span class="pi">:</span> <span class="s">8080</span>
                <span class="s">vip</span><span class="pi">:</span>
                    <span class="s">prefix</span><span class="pi">:</span> <span class="s">server-lb</span>
                    <span class="s">port</span><span class="pi">:</span> <span class="s">80</span>
                    <span class="s">advertise</span><span class="pi">:</span> <span class="s">true</span>
</code></pre>
</div>

<p>Defining a VIP is additional information that can be applied to a port. VIPs are defined by a prefix, an internal port, and an external port. The internal port in this example is 8080 and the external port is 80. The prefix is automatically expanded to become an address of the form:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;prefix&gt;.&lt;framework-name&gt;.l4lb.thisdcos.directory
</code></pre>
</div>

<p>In the example above, a server task can be accessed through the address:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>server-lb.hello-world.l4lb.thisdcos.directory:80
</code></pre>
</div>

<h1 id="testing">Testing</h1>

<p>The SDK provides assistance for writing both unit and integration tests.</p>

<h2 id="unit-tests">Unit tests</h2>

<p>Unit tests enable you to make sure that changes to your dependencies do not result in breaking changes to your frameworks. The SDK uses the standard JUnit testing system. The hello-world framework provides <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/src/test/java/com/mesosphere/sdk/helloworld/scheduler/HelloWorldServiceSpecTest.java">some example unit tests</a>.</p>

<p><strong>Important:</strong> In order to avoid unintentional execution of other framework tests, you must include <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/build.gradle#L40-L45">a test filter similar to the one defined by the hello-world framework</a>.</p>

<p>Unit tests that follow the pattern described above will be automatically run on all pull requests, and test failures will block merges. Unit tests can be manually executed either through standard IDE test integrations or through standard gradle commands.</p>

<ul>
  <li>
    <p>All tests: <code class="highlighter-rouge">gradlew check</code></p>
  </li>
  <li>
    <p>Individual framework: <code class="highlighter-rouge">gradlew check -p frameworks/&lt;framework-name&gt;</code></p>
  </li>
</ul>

<h2 id="integration-tests">Integration tests</h2>

<p>Within the context of the SDK, integration tests validate expected service behavior in a DC/OS cluster. The library that provides the majority of the functionality required to write such tests is called <a href="https://github.com/dcos/shakedown">shakedown</a>. Shakedown provides capabilities that make it easy to perform service operations such as install, uninstall, configuration update, software upgrade, rollback, and pod restart. As with unit tests, these tests are run against every pull request and failures blocks merges. The hello-world framework provides <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/integration/tests/test_sanity.py">some example integration tests</a>.</p>

<p>You can run integration tests manually using <code class="highlighter-rouge">py.test</code>.  The
integration tests assume you have a running DC/OS cluster, and have
installed the
<a href="https://docs.mesosphere.com/1.8/usage/cli/install/">DC/OS CLI</a>.</p>

<p>Here’s an example of running the tests for the <code class="highlighter-rouge">helloworld</code> framework:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>virtualenv -p python3 venv
<span class="gp">$ </span><span class="nb">source </span>venv/bin/activate
<span class="gp">$ </span>pip install -r tools/requirements.txt
<span class="gp">$ </span>py.test frameworks/helloworld/
</code></pre>
</div>

<h1 id="advanced-dcos-service-definition">Advanced DC/OS Service Definition</h1>

<h2 id="servicespec-yaml"><code class="highlighter-rouge">ServiceSpec</code> (YAML)</h2>

<p>The most basic set of features present in the YAML representation of the <code class="highlighter-rouge">ServiceSpec</code> are <a href="#service-spec">presented above</a>. The remaining features are introduced below.</p>

<h3 id="containers">Containers</h3>

<p>Each pod runs inside a single container. The <code class="highlighter-rouge">ServiceSpec</code> specifies the Docker image to run for that container, the virtual network memberships, and the POSIX resource limits for every task that runs inside that container. In the example below, the soft limit for number of open file descriptors for any task in the “hello” pod is set to 1024, and the hard limit to 2048:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">image</span><span class="pi">:</span> <span class="s">ubuntu</span>
    <span class="s">networks</span><span class="pi">:</span>
      <span class="s">dcos</span><span class="pi">:</span> <span class="pi">{}</span>
    <span class="s">rlimits</span><span class="pi">:</span>
      <span class="s">RLIMIT_NOFILE</span><span class="pi">:</span>
        <span class="s">soft</span><span class="pi">:</span> <span class="s">1024</span>
        <span class="s">hard</span><span class="pi">:</span> <span class="s">2048</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
</code></pre>
</div>

<p>Currently an empty YAML dictionary is passed as the body for each network definition under <code class="highlighter-rouge">networks</code>, since we only support joining virtual networks by name, but in the future it will be possible to specify port mappings and other information in a network definition.</p>

<p><strong>Note:</strong> Your framework must be run as the root user in order to raise rlimits beyond the default for a process. For a full list of which rlimits are supported, refer to <a href="https://github.com/apache/mesos/blob/master/docs/posix_rlimits.md">the Mesos documentation on rlimits</a>.</p>

<h3 id="placement-rules">Placement Rules</h3>

<p>Pods specifications may be configured with placement rules which describe where and how those pods may be deployed in the cluster. This setting supports all <a href="https://mesosphere.github.io/marathon/docs/constraints.html">Marathon-style placement operators</a>, using either of the following formats: <code class="highlighter-rouge">["field", "operator"[, "parameter"]]</code>, or <code class="highlighter-rouge">field:operator[:parameter]</code>. If you require placement logic that isn’t offered by the default Marathon-style placement operators, you should consider using <a href="#placement-rules">PlacementRules in Java</a>.</p>

<p>We recommend exposing placement constraints as templated out configuration settings, so that they may be easily customized by end-users. For example, your YAML specification may contain the following:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">3</span>
    <span class="s">placement</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">HELLO_PLACEMENT</span><span class="pi">}}</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
</code></pre>
</div>

<p>In this example your configuration would expose a <code class="highlighter-rouge">HELLO_PLACEMENT</code> configuration setting with some default value. You may then provide a default value for that setting, such as <code class="highlighter-rouge">"hostname:UNIQUE"</code> to ensure that no two hello instances are on the same agent at a time, or <code class="highlighter-rouge">“rack_id:LIKE:rack-foo-.*”</code> to ensure that hello instances are only placed on agents with a <code class="highlighter-rouge">rack_id</code> that starts with <code class="highlighter-rouge">“rack-foo-”</code>. Multiple placement rules may be ANDed together by separating them with a comma, e.g. <code class="highlighter-rouge">“hostname:UNIQUE,rack_id:LIKE:rack-foo-.*”</code>.</p>

<p><a name="resource-sets"></a></p>
<h3 id="resource-sets">Resource Sets</h3>

<p>A Mesos task is always a process that consumes some resources. In the example below, the server task is a command that prints “hello” to a file while consuming 1.0 CPUs, 256 MB of memory, and 50 MB of disk space for its volume.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
</code></pre>
</div>

<p>An equivalent way to define the same task is as follows:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">hello-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources/</span>
</code></pre>
</div>

<p>In this case, the resources are declared separately from the server task in a resource set named <code class="highlighter-rouge">hello-resources</code>. They are referenced by a <code class="highlighter-rouge">resource-set</code> element in the task definition. A task continues to be defined as the combination of a process to run and resources to consume. This alternate formulation provides you with increased  flexibility:  you can now define multiple processes that can consume the same resources.</p>

<p><strong>Important:</strong> At any given point in time, only a single process may be consuming a given set of resources. <strong>Resources may never be shared simultaneously by multiple tasks</strong>.  Any attempt to launch a task consuming an already consumed resource-set will result in the killing of the task which is currently running and the launch of the new task.</p>

<p>This alternative formulation of tasks is useful when several tasks should be sequenced in the same container and have a cumulative effect on data in a volume. For example, if you want to initialize something before running the long running server task, you could write the following:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">hello-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">initialize</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">FINISHED</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">initialize</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
</code></pre>
</div>

<p>Both tasks now refer to the same resource set. However, since they cannot consume this resource simultaneously we must impose an ordering. We want to run the initialize task, allow it to finish, and then start the long running server task, which produces the following output in the hello-container-path/output file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>initialize
hello
</code></pre>
</div>

<p>Provide an ordering by specifying a custom deployment plan. The final YAML file would be:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">hello-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">50</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">initialize</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">FINISHED</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">initialize</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
<span class="s">plans</span><span class="pi">:</span>
  <span class="s">deploy</span><span class="pi">:</span>
    <span class="s">phases</span><span class="pi">:</span>
      <span class="s">hello-deploy</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">hello</span>
        <span class="s">steps</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s">default</span><span class="pi">:</span> <span class="pi">[[</span><span class="nv">initialize</span><span class="pi">],</span> <span class="pi">[</span><span class="nv">server</span><span class="pi">]]</span>
</code></pre>
</div>

<p>The plan defined above, the instance of the hello pod with index 0 should first have the initialize task run, followed by the server task. Because they refer to the same resource set and their commands print to the same file in the same volume, the sequencing of tasks has a cumulative effect on the container context. For a fully featured practical example of this pattern, <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/hdfs/src/main/dist/hdfs_svc.yml">see the HDFS service here</a>.</p>

<h3 id="sidecar-plans">Sidecar Plans</h3>

<p>You can include arbitrary additional plans beyond the deploy plan.  These may be executed at runtime to performance, for example, maintenance operations like backup.  Below we have an example describing how to declare a sidecar plan.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">resource-sets</span><span class="pi">:</span>
      <span class="s">hello-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
      <span class="s">sidecar-resources</span><span class="pi">:</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">$SLEEP_DURATION"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">hello-resources</span>
        <span class="s">env</span><span class="pi">:</span>
          <span class="s">SLEEP_DURATION</span><span class="pi">:</span> <span class="s">1000</span>
      <span class="s">sidecar</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">FINISHED</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">$PLAN_PARAMETER1</span><span class="nv"> </span><span class="s">$PLAN_PARAMETER2</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">output"</span>
        <span class="s">resource-set</span><span class="pi">:</span> <span class="s">sidecar-resources</span>
<span class="s">plans</span><span class="pi">:</span>
  <span class="s">sidecar-example</span><span class="pi">:</span>
    <span class="s">strategy</span><span class="pi">:</span> <span class="s">serial</span>
    <span class="s">phases</span><span class="pi">:</span>
      <span class="s">sidecar-deploy</span><span class="pi">:</span>
        <span class="s">strategy</span><span class="pi">:</span> <span class="s">parallel</span>
        <span class="s">pod</span><span class="pi">:</span> <span class="s">hello</span>
        <span class="s">tasks</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">sidecar</span><span class="pi">]</span>
</code></pre>
</div>

<p>The command definition for the sidecar task includes environment variables, <code class="highlighter-rouge">PLAN_PARAMETER1</code> and <code class="highlighter-rouge">PLAN_PARAMETER2</code>, that are not defined elsewhere in the service definition. You can supply these parameters when the plan is initiated.  The parameters will be propagated to the environment of every task launched by the plan.</p>

<p>To initiate the plan, execute an HTTP POST request against the <code class="highlighter-rouge">/v1/plans/sidecar-example/start</code> endpoint with the header <code class="highlighter-rouge">Content-Type: application/json</code> set and a JSON body consisting of environment variable name/value pairs. For example:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl -k -X POST -H <span class="s2">"Authorization: token=</span><span class="nv">$AUTH_TOKEN</span><span class="s2">"</span> -H <span class="s2">"Content-Type: application/json"</span> --data <span class="s1">'{"PLAN_PARAMETER1": "sidecar", "PLAN_PARAMETER2": "plan"}'</span> http://&lt;dcos_url&gt;/service/hello-world/v1/plans/sidecar-example/start
</code></pre>
</div>

<p>You can also use the DC/OS CLI:</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dcos <span class="nv">$FRAMEWORK_NAME</span> plan start sidecar-example <span class="nv">PLAN_PARAMETER1</span><span class="o">=</span>sidecar,PLAN_PARAMETER2<span class="o">=</span>plan
</code></pre>
</div>

<p>When no parameters are specified, the body of the POST request must be an empty JSON object (<code class="highlighter-rouge"><span class="p">{}</span></code>). Supply default values with standard Bash syntax. In the above case, you can declare the default value of <code class="highlighter-rouge">PLAN_PARAMETER1</code> to be <code class="highlighter-rouge">sidecar</code> by changing the task’s command string to <code class="highlighter-rouge">echo ${PLAN_PARAMETER1:-sidecar} &gt;&gt; output</code>.</p>

<p>Monitor sidecar plan progress like any other plan: by issuing GET requests against the <code class="highlighter-rouge">/v1/plans/sidecar-example</code> endpoint.</p>

<p>Because the sidecar task is defined inside the hello pod, it will run inside the hello pod when the sidecar-example plan is started.  This gives it access to all the resources in the hello pod, including any persistent volumes that may be present.  In this way, a backup plan could be constructed and executed on demand.</p>

<h3 id="uris">URIs</h3>

<p>You can include an arbitrary list of URIs to download before launching a task or before launching a pod. The Mesos fetcher automatically extracts and caches the URIs. To attach URIs to the context of a task, modify the YAML as below:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">uris</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s">https://foo.bar.com/package.tar.gz</span>
          <span class="pi">-</span> <span class="s">https://foo.bar.com/bundle.tar.gz</span>
</code></pre>
</div>

<p>To add URIs to a pod, modify the YAML as below:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">uris</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">https://foo.bar.com/package.tar.gz</span>
      <span class="pi">-</span> <span class="s">https://foo.bar.com/bundle.tar.gz</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
</code></pre>
</div>

<p>URIs included in a pod are accessible to all its tasks.</p>

<h3 id="configuration-templates">Configuration Templates</h3>

<p>It is common for a service to require configuration files to be present in the context of a task.  The SDK provides a method for defining and placing task-specific configuration files. A configuration file is template that can be dynamically rendered by environment variables. Add a configuration file to a task in the following way:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">configs</span><span class="pi">:</span>
          <span class="s">config.xml</span><span class="pi">:</span>
            <span class="s">template</span><span class="pi">:</span> <span class="s2">"</span><span class="s">config.xml.mustache"</span>
            <span class="s">dest</span><span class="pi">:</span> <span class="s">etc/config.xml</span>
</code></pre>
</div>

<p>The template content may be templated using the <a href="https://mustache.github.io/mustache.5.html">mustache format</a>. Any templated parameters in the file may be automatically populated with environment variables within the task, by including the <code class="highlighter-rouge">bootstrap</code> utility in your tasks. See <a href="#bootstrap">Bootstrap Tool</a> for more information. at the beginning of the task.</p>

<p>For example, say you had a container with the following environment variables:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nv">PORT_FOO</span><span class="o">=</span>1984
<span class="nv">FRAMEWORK_NAME</span><span class="o">=</span>mysvc
</code></pre>
</div>

<p>And a <code class="highlighter-rouge">config.xml.mustache</code> template like this:</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;config&gt;</span>
  <span class="nt">&lt;port&gt;</span>{{PORT_FOO}}<span class="nt">&lt;/port&gt;</span>
  <span class="nt">&lt;service&gt;</span>{{FRAMEWORK_NAME}}<span class="nt">&lt;/service&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/config&gt;</span>
</code></pre>
</div>

<p>When the <code class="highlighter-rouge">bootstrap</code> helper is run, it would automatically create a populated version of that file in <code class="highlighter-rouge">etc/config.xml</code>:</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;config&gt;</span>
  <span class="nt">&lt;port&gt;</span>1984<span class="nt">&lt;/port&gt;</span>
  <span class="nt">&lt;game&gt;</span>mysvc<span class="nt">&lt;/game&gt;</span>
  <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;config&gt;</span>
</code></pre>
</div>

<p>To be clear, the config templating provided by the <code class="highlighter-rouge">bootstrap</code> tool may be applied to <em>any text format</em>, not just XML as in this example. This makes it a powerful tool for handling any config files your service may need. Read more about setting this up in the <a href="#bootstrap">Bootstrap Tool</a> section.</p>

<h3 id="task-environment">Task Environment</h3>

<p>While some environment variables are included by default in each task as a convenience, you may also specify custom environment variables yourself.</p>

<p>You can define the environment of a task in a few different ways. In the YML <code class="highlighter-rouge">ServiceSpec</code>, it can be defined in the following way.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">env</span><span class="pi">:</span>
          <span class="s">FOO</span><span class="pi">:</span> <span class="s">bar</span>
          <span class="s">BAZ</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">BAZ</span><span class="pi">}}</span>
</code></pre>
</div>

<p>As in any other case, environment variables may be templated values. Schedulers written using the SDK also detect particular formats of environment. To inject a common set of environment variables into the contexts of all tasks, you can add environment variables to the scheduler’s context in the form below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TASKCFG_ALL_&lt;KEY&gt;: &lt;VALUE&gt;
</code></pre>
</div>

<p>For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TASKCFG_ALL_FOO: BAR → FOO: BAR
</code></pre>
</div>

<p>To inject environment variables into the contexts of all instances of a particular pod type, define environment variables of the form below to the scheduler’s context.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TASKCFG_&lt;POD-NAME&gt;_&lt;KEY&gt;: &lt;VALUE&gt;
</code></pre>
</div>

<p>For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TASKCFG_HELLO_BAZ: BAZ → BAZ: BAZ
</code></pre>
</div>

<p><a name="bootstrap"></a></p>
<h3 id="task-bootstrap">Task Bootstrap</h3>

<p>The <code class="highlighter-rouge">cmd</code> in each task defines what’s run for the lifetime of that task. A common problem when defining tasks is providing some sort of initial configuration, waiting for hosts to resolve, and other up-front work.</p>

<p>The <code class="highlighter-rouge">bootstrap</code> utility executable is available for running at the start of your tasks to perform these common task operations, including:</p>

<ul>
  <li>Logging <code class="highlighter-rouge">env</code> (useful for debugging)</li>
  <li>Rendering any <code class="highlighter-rouge">configs</code> provided in the task definition and writing the result to the configured <code class="highlighter-rouge">dest</code>s.</li>
  <li>Waiting for the task’s own hostname to be resolvable, or optionally wait for other custom hostnames to be resolvable, before exiting</li>
</ul>

<p>These operations may be enabled, disabled, and customized via <code class="highlighter-rouge">bootstrap</code>s commandline arguments in your <code class="highlighter-rouge">cmd</code>. See the <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/bootstrap/main.go">source code</a> for more details on what specific options are available.</p>

<p>Including <code class="highlighter-rouge">bootstrap</code> in your tasks is a manual but straightforward operation. First, you should to add it to the package definition (<code class="highlighter-rouge">resources.json</code> and <code class="highlighter-rouge">marathon.json.mustache</code>), then include it in the service definition (<code class="highlighter-rouge">svc.yml</code>):</p>

<p><code class="highlighter-rouge">resources.json</code>:</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"assets"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"uris"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="p">,</span><span class="w">
      </span><span class="nt">"bootstrap-zip"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{artifact-dir}}/bootstrap.zip"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">marathon.json.mustache</code>:</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{service.name}}"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"cpus"</span><span class="p">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w">
  </span><span class="nt">"mem"</span><span class="p">:</span><span class="w"> </span><span class="mi">2048</span><span class="p">,</span><span class="w">
  </span><span class="nt">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"BOOTSTRAP_URI"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{resource.assets.uris.bootstrap-zip}}"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"..."</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p><code class="highlighter-rouge">svc.yml</code>:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">uris</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="pi">{{</span><span class="nv">BOOTSTRAP_URI</span><span class="pi">}}</span> <span class="c1"># fetch/unpack bootstrap.zip into this pod</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./bootstrap</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span> <span class="c1"># run 'bootstrap' before 'hello'</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">configs</span><span class="pi">:</span>
          <span class="s">config.xml</span><span class="pi">:</span>
            <span class="s">template</span><span class="pi">:</span> <span class="s2">"</span><span class="s">config.xml.mustache"</span>
            <span class="s">dest</span><span class="pi">:</span> <span class="s">etc/config.xml</span>
</code></pre>
</div>

<p>Now the <code class="highlighter-rouge">bootstrap</code> executable will automatically be run at the start of <code class="highlighter-rouge">hello</code> tasks. By default it will first print the <code class="highlighter-rouge">env</code>, then will handle rendering the <code class="highlighter-rouge">config.xml.mustache</code> template to <code class="highlighter-rouge">etc/config.xml</code>, then wait for the hello task’s hostname to be locally resolvable.</p>

<h3 id="health-checks">Health Checks</h3>

<p>If a task is unhealthy, the scheduler will kill and restart it.  You may define a health check for a task by adding a <code class="highlighter-rouge">health-check</code> parameter to its <code class="highlighter-rouge">TaskSpec</code>:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
      <span class="s">health-check</span><span class="pi">:</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./check-up"</span>
        <span class="s">interval</span><span class="pi">:</span> <span class="s">5</span>
        <span class="s">grace-period</span><span class="pi">:</span> <span class="s">30</span>
        <span class="s">max-consecutive-failures</span><span class="pi">:</span> <span class="s">3</span>
        <span class="s">delay</span><span class="pi">:</span> <span class="s">0</span>
        <span class="s">timeout</span><span class="pi">:</span> <span class="s">10</span>
</code></pre>
</div>

<p>The interval, grace-period, delay, and timeout elements are denominated in seconds. If the maximum consecutive number of failures is exceeded, the task will be killed.</p>

<h3 id="readiness-checks">Readiness Checks</h3>

<p>Use a readiness check when a task must perform some initialization before subsequent steps run.  By default, a <a href="#plans">step</a> will be <code class="highlighter-rouge">COMPLETE</code> when its task reaches its goal state (<code class="highlighter-rouge">RUNNING</code> or <code class="highlighter-rouge">COMPLETED</code>), but if the task has a <strong>readiness check</strong>, its step won’t be <code class="highlighter-rouge">COMPLETE</code> until its readiness check passes.  You may define a readiness check for a task by adding a <code class="highlighter-rouge">readiness-check</code> parameter to its <code class="highlighter-rouge">TaskSpec</code>:</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1000"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">0.1</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
      <span class="s">readiness-check</span><span class="pi">:</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./readiness-check"</span>
        <span class="s">interval</span><span class="pi">:</span> <span class="s">5</span>
        <span class="s">delay</span><span class="pi">:</span> <span class="s">0</span>
        <span class="s">timeout</span><span class="pi">:</span> <span class="s">10</span>
</code></pre>
</div>

<p>The interval, delay, and timeout elements are denominated in seconds.</p>

<h3 id="volumes">Volumes</h3>

<p>Persistent volumes allow data to be stored on disks and survive.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-world"</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">hello</span><span class="pi">:</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">3</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">hello</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">hello-container-path/output</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">$SLEEP_DURATION"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="s">1.0</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="s">256</span>
        <span class="s">volume</span><span class="pi">:</span>
          <span class="s">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">hello-container-path"</span>
          <span class="s">type</span><span class="pi">:</span> <span class="s">ROOT</span>
          <span class="s">size</span><span class="pi">:</span> <span class="s">5000</span>
</code></pre>
</div>

<p>The path is relative to the sandbox path if not preceded by a leading “/”. The sandbox path is always available in the environment variable MESOS_SANDBOX.  The different between ROOT and MOUNT volumes is <a href="http://mesos.apache.org/documentation/latest/multiple-disk/">documented here</a>. The PATH type is not currently supported.</p>

<p><a name="proxy"></a></p>
<h3 id="proxy">Proxy</h3>

<p>The proxy allows you to expose more than one endpoint through Admin Router. The proxy is only supported on DC/OS 1.9 and newer clusters. An example of a correct proxy implementation can be found in the proxylite framework in this repository.</p>

<p><strong>Important:</strong> Read through all these instructions before you begin.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">web-url</span><span class="pi">:</span> <span class="s">http://proxylite-0-server.{{FRAMEWORK_NAME}}.mesos:{{PROXYLITE_PORT}}</span>
<span class="s">pods</span><span class="pi">:</span>
  <span class="s">proxylite</span><span class="pi">:</span>
    <span class="s">image</span><span class="pi">:</span> <span class="s">mesosphere/proxylite:2.1.0</span>
    <span class="s">count</span><span class="pi">:</span> <span class="s">1</span>
    <span class="s">tasks</span><span class="pi">:</span>
      <span class="s">server</span><span class="pi">:</span>
        <span class="s">goal</span><span class="pi">:</span> <span class="s">RUNNING</span>
        <span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/proxylite/run.sh"</span>
        <span class="s">cpus</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">PROXYLITE_CPUS</span><span class="pi">}}</span>
        <span class="s">memory</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">PROXYLITE_MEM</span><span class="pi">}}</span>
        <span class="s">ports</span><span class="pi">:</span>
          <span class="s">proxylite</span><span class="pi">:</span>
            <span class="s">env-key</span><span class="pi">:</span> <span class="s">PORT_PROXYLITE</span>
            <span class="s">port</span><span class="pi">:</span> <span class="pi">{{</span><span class="nv">PROXYLITE_PORT</span><span class="pi">}}</span>
        <span class="s">env</span><span class="pi">:</span>
          <span class="s">ROOT_REDIRECT</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/example"</span>
          <span class="s">EXTERNAL_ROUTES</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/v1,/example"</span>
          <span class="s">INTERNAL_ROUTES</span><span class="pi">:</span> <span class="s2">"</span><span class="s">http://{{FRAMEWORK_NAME}}.marathon.mesos:{{PORT0}}/v1,http://example.com:80"</span>
</code></pre>
</div>

<ol>
  <li>Delete these 3 labels from your marathon application definition:
    <ul>
      <li><code class="highlighter-rouge">DCOS_FRAMEWORK_NAME</code></li>
      <li><code class="highlighter-rouge">DCOS_SERVICE_PORT_INDEX</code></li>
      <li><code class="highlighter-rouge">DCOS_SERVICE_SCHEME</code></li>
    </ul>
  </li>
  <li>
    <p>Add <code class="highlighter-rouge">ROOT_REDIRECT</code> to your service definition.</p>

    <ul>
      <li><code class="highlighter-rouge">ROOT_REDIRECT</code> sets a redirect from <code class="highlighter-rouge">/</code> (a.k.a. the root path) to a path of your choosing. For example, <code class="highlighter-rouge">/example</code> redirects <code class="highlighter-rouge">&lt;adminrouter&gt;/service/{{FRAMEWORK_NAME}}</code> to <code class="highlighter-rouge">&lt;adminrouter&gt;/service/{{FRAMEWORK_NAME}}/example</code></li>
    </ul>
  </li>
  <li>
    <p>Add <code class="highlighter-rouge">EXTERNAL_ROUTES</code> and <code class="highlighter-rouge">INTERNAL_ROUTES</code> to your service definition.</p>

    <ul>
      <li>
        <p>The <code class="highlighter-rouge">EXTERNAL_ROUTES</code> and <code class="highlighter-rouge">INTERNAL_ROUTES</code> have a 1:1 mapping (they are both comma-separated lists).</p>
      </li>
      <li>
        <p>For example, in the declaration above, if you navigate to <code class="highlighter-rouge">&lt;adminrouter&gt;/service/{{FRAMEWORK_NAME}}/v1/plan</code>, you’ll get redirected to <code class="highlighter-rouge">http://{{FRAMEWORK_NAME}}.marathon.mesos:{{PORT0}}/v1/plan</code></p>
      </li>
    </ul>
  </li>
  <li>Things to watch out for:
    <ul>
      <li>No trailing slashes in <code class="highlighter-rouge">EXTERNAL_ROUTES</code> or <code class="highlighter-rouge">INTERNAL_ROUTES</code>.</li>
      <li>The external route is <em>replaced</em> with the internal route.
        <ul>
          <li>It’s easy to think that the internal route is appended onto the external route (or is related in some other way) but that is <em>not the case</em>.</li>
          <li>For example, in the above declaration, “/v1” is replaced with “/v1”, so nothing changes. However one might use <code class="highlighter-rouge">http://{{FRAMEWORK_NAME}}.marathon.mesos:{{PORT0}}</code> as the internal route, and in that case “/v1” is replaced with “”, and “/v1/plan” would be replaced with “/plan” which would result in incorrect behavior.</li>
        </ul>
      </li>
      <li>
        <p>When the proxy starts up, it will crash if the DNS address is not resolvable (this happens when the proxy comes up before the task that it is proxying is up). This is not an issue in and of itself, as the proxy will simply be relaunched.</p>

        <p>You can avoid this relaunch by instructing the proxylite task to wait for the DNS to resolve for the task that it is proxying. For example:</p>

        <div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">cmd</span><span class="pi">:</span> <span class="s2">"</span><span class="s">./bootstrap</span><span class="nv"> </span><span class="s">-resolve-hosts=ui-0-server.{{FRAMEWORK_NAME}}.mesos</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">/proxylite/run.sh"</span>
</code></pre>
        </div>
      </li>
    </ul>
  </li>
</ol>

<h3 id="proxy-fallback">Proxy Fallback</h3>

<p>Applications may not work properly behind adminrouter. In that case, one may use <a href="https://gist.github.com/nlsun/877411115f7e3b885b5e9daa8821722f">Repoxy</a>.</p>

<h2 id="servicespec-java"><code class="highlighter-rouge">ServiceSpec</code> (Java)</h2>

<p>The YAML-based <code class="highlighter-rouge">ServiceSpec</code> is flexible and powerful, but once a service moves beyond purely declarative requirements, its static nature becomes a barrier to development. The <code class="highlighter-rouge">ServiceSpec</code> as defined in YAML is actually just a convenience for generating a Java implementation of the <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/specification/ServiceSpec.java"><code class="highlighter-rouge">ServiceSpec</code> interface</a>, which is arbitrarily modifiable by users of the SDK.</p>

<p>All of the interfaces of the <code class="highlighter-rouge">ServiceSpec</code> have default implementations. For example, the <code class="highlighter-rouge">ServiceSpec</code> interface is implemented by the <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/specification/DefaultServiceSpec.java"><code class="highlighter-rouge">DefaultServiceSpec</code></a>. The default interface implementations also provide convenient fluent style construction. For example a <code class="highlighter-rouge">DefaultServiceSpec</code> can be constructed in the following way:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">DefaultServiceSpec</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="n">FRAMEWORK_NAME</span><span class="o">)</span>
    <span class="o">.</span><span class="na">role</span><span class="o">(</span><span class="n">ROLE</span><span class="o">)</span>
    <span class="o">.</span><span class="na">principal</span><span class="o">(</span><span class="n">PRINCIPAL</span><span class="o">)</span>
    <span class="o">.</span><span class="na">apiPort</span><span class="o">(</span><span class="mi">8080</span><span class="o">)</span>
    <span class="o">.</span><span class="na">zookeeperConnection</span><span class="o">(</span><span class="s">"foo.bar.com"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">pods</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">pods</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre>
</div>

<p>The same pattern holds for all components of the <code class="highlighter-rouge">ServiceSpec</code>. <a href="#resource-sets">Resource sets</a> are one area of difference between Java and YAML <code class="highlighter-rouge">ServiceSpec</code> definitions. While the YAML interface allows specification with implicitly defined resource sets, the Java interface is more strict and requires explicit use of resource sets when implementing a <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/specification/TaskSpec.java">TaskSpec</a>.</p>

<p><a name="placement-rules"></a></p>
<h3 id="placement-rules-1">Placement Rules</h3>

<p>The physical location of tasks in Mesos clusters has important implications for the availability and robustness to data loss of stateful services. You can control the placement of pods by adding placement rules to PodSpecs.</p>

<p>You can add placement constraints to a PodSpec that has already been defined either through YAML or Java. This Java interface allows full customization of placement logic, whereas the <a href="#placement-rules">YAML interface</a> only supports specifying Marathon-style constraints. Note that the two will automatically be ANDed together if they are both provided. This allows users to specify their own deployment constraints on top of any hardcoded service constraints.</p>

<p>One common placement constraint is to avoid placing pods of the same type together in order to avoid correlated failures. If, for example, you want to deploy all pods of type “hello” on different Mesos agents, extend the PodSpec as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PodSpec</span> <span class="n">helloPodSpec</span> <span class="o">=</span> <span class="n">DefaultPodSpec</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">helloPodSpec</span><span class="o">)</span>
        <span class="o">.</span><span class="na">placementRule</span><span class="o">(</span><span class="n">TaskTypeRule</span><span class="o">.</span><span class="na">avoid</span><span class="o">(</span><span class="s">"hello"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre>
</div>

<p>This is equivalent to specifying a “hostname:UNIQUE” Marathon constraint in your YAML specification. Let’s look at a more complicated placement rule and how multiple rules may be composed. If, for example, pods of type “hello” should avoid both pods of the same type and colocate with those of “world” type, this could be expressed as:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PodSpec</span> <span class="n">helloPodSpec</span> <span class="o">=</span> <span class="n">DefaultPodSpec</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="n">helloPodSpec</span><span class="o">)</span>
        <span class="o">.</span><span class="na">placementRule</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">AndRule</span><span class="o">(</span>
                        <span class="n">TaskTypeRule</span><span class="o">.</span><span class="na">avoid</span><span class="o">(</span><span class="s">"hello"</span><span class="o">),</span>
                        <span class="n">TaskTypeRule</span><span class="o">.</span><span class="na">colocateWith</span><span class="o">(</span><span class="s">"world"</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre>
</div>

<p>In addition to the AndRule, OrRule and NotRule are also available to complete the necessary suite of boolean operators. Many placement rules for common scenarios are already provided by the SDK. Consult the com.mesosphere.sdk.offer.constrain package to find the list of placement rules currently available. <a href="https://github.com/mesosphere/dcos-commons/blob/50e54727/frameworks/hdfs/src/main/java/com/mesosphere/sdk/hdfs/scheduler/Main.java#L52-L69">A practical example is also available in the HDFS framework</a>.</p>

<p><a name="custom-plans-java"></a></p>
<h2 id="custom-plans-java">Custom Plans (Java)</h2>

<p>The YAML-based definition of plans is limited to defining custom deployment plans. You can use of the appropriate <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/scheduler/plan/Plan.java">Java plan interface</a> for arbitrary flexibility in plan construction, be it for service deployment or any other purpose by <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/scheduler/plan/Plan.java">s</a>. Default implementations of all interfaces are provided. <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/scheduler/plan/DefaultPlan.java">DefaultPlan</a>, <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/scheduler/plan/DefaultPhase.java">DefaultPhase</a>, and <a href="https://github.com/mesosphere/dcos-commons/blob/master/sdk/scheduler/src/main/java/com/mesosphere/sdk/scheduler/plan/DefaultStep.java">DefaultStep</a> will be of interest to advanced service authors.</p>

<p><a name="internals"></a></p>
<h3 id="internals">Internals</h3>

<p>Understanding plan execution can help you take advantage of the full capabilities of creating custom plans.</p>

<p><img src="img/dev-guide-plans-and-the-offer-cycle.png" alt="plans and the offer cycle" /></p>

<p>There are at least two plans defined at any given time for a scheduler: a deploy plan and a recovery plan.</p>

<p><strong>Plan managers</strong> determine what steps in a plan should be executed.</p>

<p>A <strong>plan coordinator</strong> passes relevant information between plan managers so they understand what work other plan managers are doing to avoid contention. The output of the plan coordinator is a set of steps that are candidates for execution.</p>

<p>The <strong>plan scheduler</strong> attempts to match offers from Mesos with the needs of each candidate step. If a step’s requirements are met, Mesos operations are performed. The operations performed are also reported to the steps so they can determine what state transitions to make.</p>

<p>The state transitions of steps determine the overall progress of plans as they are the leaf elements of the Plan → Phase → Step hierarchy.</p>

<table>
  <tr>
    <td>State</td>
    <td>Meaning</td>
  </tr>
  <tr>
    <td>Pending</td>
    <td>No operations have been performed.</td>
  </tr>
  <tr>
    <td>Prepared</td>
    <td>Any tasks/pods that needed to be killed have been killed.</td>
  </tr>
  <tr>
    <td>Starting</td>
    <td>Operations have been performed, but their status has not yet been reported by Mesos.</td>
  </tr>
  <tr>
    <td>Complete</td>
    <td>The desired work has been accomplished.</td>
  </tr>
  <tr>
    <td>Waiting</td>
    <td>Outside intervention has occurred blocking processing.</td>
  </tr>
  <tr>
    <td>Error</td>
    <td>An error has occurred in construction or execution.</td>
  </tr>
</table>

<p>Typically, a step transitions through states as follows: Pending → Prepared → Starting → Complete. There are no enforced restrictions on state transitions. However, there are conventional meanings to states that determine the behavior of plan execution. The most important concept here is the InProgress meta-state. By default, if a step is prepared or starting, it is determined to be InProgress. This state is the core of the anti-contention mechanism between plans. If a step is in progress, by default, no other plan will attempt to execute steps pertaining to the same pod instance</p>

<p>Steps in the pending or prepared states undergo offer evaluation. That is, matching against Mesos offers is attempted. There is no need for offer evaluation in any of the other states.</p>

<h3 id="strategy">Strategy</h3>

<p>Fundamentally, the execution of a plan is the execution of steps in some order. The component that determines this ordering is a strategy. Every element of a plan has a strategy that determines the deployment order of its child elements. A plan has a strategy that determines the deployment order of phases. A phase, in turn, has has a strategy that determines the deployment order of steps.</p>

<h3 id="example">Example</h3>

<p>In general, a step encapsulates an instance of a pod and the tasks to be launched in that pod.  We recommend using the DefaultStepFactory to generate steps. The DefaultStepFactory consults the ConfigStore and StateStore and creates a step with the appropriate initial status. For example, if a pod instance has never been launched before, the step will start in a pending state. However, if a pod instance is already running and its goal state is RUNNING, its initial status will be COMPLETE.</p>

<p>You could generate three steps in the following way:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">StepFactory</span> <span class="n">stepFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultStepFactory</span><span class="o">(</span><span class="n">configStore</span><span class="o">,</span> <span class="n">stateStore</span><span class="o">);</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Step</span><span class="o">&gt;</span> <span class="n">steps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">steps</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stepFactory</span><span class="o">.</span><span class="na">getStep</span><span class="o">(</span><span class="n">podInstance0</span><span class="o">,</span> <span class="n">tasksToLaunch0</span><span class="o">));</span>
<span class="n">steps</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stepFactory</span><span class="o">.</span><span class="na">getStep</span><span class="o">(</span><span class="n">podInstance1</span><span class="o">,</span> <span class="n">tasksToLaunch1</span><span class="o">));</span>
<span class="n">steps</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stepFactory</span><span class="o">.</span><span class="na">getStep</span><span class="o">(</span><span class="n">podInstance2</span><span class="o">,</span> <span class="n">tasksToLaunch2</span><span class="o">));</span>
</code></pre>
</div>

<p>Then steps can be grouped in a phase with an accompanying strategy.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Phase</span> <span class="n">phase</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultPhase</span><span class="o">(</span>
        <span class="s">"phase-name"</span><span class="o">,</span>
        <span class="n">steps</span><span class="o">,</span>
        <span class="k">new</span> <span class="n">SerialStrategy</span><span class="o">&lt;&gt;(),</span>
        <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">());</span> <span class="c1">// No errors</span>
</code></pre>
</div>

<p>The phase defined above will execute its steps in a serial order. The phase can be added to a plan.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Plan</span> <span class="n">customPlan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultPlan</span><span class="o">(</span>
        <span class="s">"plan-name"</span><span class="o">,</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">phase</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">ParallelStrategy</span><span class="o">&lt;&gt;());</span>
</code></pre>
</div>

<p>In the plan above, a parallel strategy is defined so all phases will be executed simultaneously. There is only one phase in this case. Once a plan is defined, it must be added to the PlanCoordinator/PlanManager system <a href="#internals">described above</a>.</p>

<p>The easiest way to do this is to extend the DefaultService provided by the SDK.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomService</span> <span class="kd">extends</span> <span class="n">DefaultService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">CustomService</span><span class="o">(</span><span class="n">File</span> <span class="n">yamlFile</span><span class="o">,</span> <span class="n">Plan</span> <span class="n">customPlan</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">RawServiceSpecification</span> <span class="n">rawServiceSpecification</span> <span class="o">=</span>
                <span class="n">YAMLServiceSpecFactory</span><span class="o">.</span><span class="na">generateRawSpecFromYAML</span><span class="o">(</span><span class="n">yamlFile</span><span class="o">);</span>
        <span class="n">DefaultServiceSpec</span> <span class="n">defaultServiceSpec</span> <span class="o">=</span>
                <span class="n">YAMLServiceSpecFactory</span><span class="o">.</span><span class="na">generateServiceSpec</span><span class="o">(</span><span class="n">rawServiceSpecification</span><span class="o">);</span>

        <span class="n">serviceSpec</span> <span class="o">=</span> <span class="n">defaultServiceSpec</span><span class="o">;</span>
        <span class="n">init</span><span class="o">();</span>
        <span class="n">plans</span> <span class="o">=</span> <span class="n">generatePlansFromRawSpec</span><span class="o">(</span><span class="n">rawServiceSpecification</span><span class="o">);</span>
        <span class="n">plans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">customPlan</span><span class="o">);</span>

        <span class="n">register</span><span class="o">(</span><span class="n">serviceSpec</span><span class="o">,</span> <span class="n">plans</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>All plans provided in the register call will be executed.</p>

</div>
</div>
</body>

</html>
