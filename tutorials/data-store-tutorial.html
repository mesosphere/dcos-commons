<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">







<head>
<title>Data Store Tutorial</title>
<link rel="stylesheet" type="text/css" media="all" href="../style/gh-basic.css" />
<link rel="shortcut icon" type="image/png" href="https://mesosphere.com/favicon.ico"/>
<!-- The Dropdown library is written by Stephen Morley, licensed CC0 1.0 Universal (Public Domain Dedication)-->
<link rel="stylesheet" type="text/css" media="all" href="../style/Dropdown.css" />
<script src="../style/Dropdown.js"></script>
<style type="text/css">
/* set the background color of menu items */
.dropdown, .dropdown ul { background: #555555; clear: both; }
/* set the background color of active items */
.dropdown li:hover > a, .dropdown li:hover > span, .dropdown li.dropdownOpen > a, .dropdown li.dropdownOpen > span { background: #af87e0; }
/* pad items, set their text color, and fade their background color */
.dropdown a, .dropdown span { padding: 0.25em 0.5em; color: white; transition: background 0.2s; }
/* show '+' on expandable items */
.dropdown span:after { content: " +"; }

/* toc style: remove extra margin between elements */
#markdown-toc ul { margin: 0; }
</style>
</head>

<body>
<div id="wrapper">

<a href="..">
<img style="float: left; margin-bottom: 2em" src="https://mesosphere.com/wp-content/themes/mesosphere/library/images/assets/dcos-sdk-logo.png" width="250" alt="DC/OS Software Development Kit" />
</a>
<img style="float: right" src="https://img.shields.io/badge/Status-Alpha-BF97F0.svg?style=flat-square" alt="Status: Alpha" />

<ul class="dropdown" style="clear: both">
  <li>
    <a href="..">Home</a>
  </li>
  <li>
    <span>Documentation</span>
    <ul>
      
      
      
      <li><a href="../operations-guide.html">SDK Operations Guide</a></li>
      
      <li><a href="../developer-guide.html">SDK Developer Guide</a></li>
      
      <li><a href="../yaml-reference.html">YAML Reference</a></li>
      
      <li><a href="../glossary.html">Glossary</a></li>
      
      <li><a href="../faq.html">Frequently Asked Questions</a></li>
      
      <li><a href="../ops-guide"></a></li>
      
      <li><a href="../swagger-api">REST APIs</a></li>
      <li><a href="../api">Javadoc Reference</a></li>
    </ul>
  </li>
  <li>
    <span>Tutorials</span>
    <ul>
      
      
      
      <li><a href="../tutorials/kafka-tutorial.html">Kafka Tutorial</a></li>
      
      <li><a href="../tutorials/quick-start-java.html">Quick Start (Java)</a></li>
      
      <li><a href="../tutorials/data-store-tutorial.html">Data Store Tutorial</a></li>
      
      <li><a href="../tutorials/automatic-repair.html">Automatic Repair</a></li>
      
    </ul>
  </li>
  <li>
    <span>Services</span>
    <ul>
      
      
      
      
      <li>
        
        <span>Elastic</span>
        
        <ul>
          
          
          <li><a href="../services/elastic/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="../services/elastic/install.html">Install and Customize</a></li>
          
          <li><a href="../services/elastic/upgrade.html">Upgrade</a></li>
          
          <li><a href="../services/elastic/uninstall.html">Uninstall</a></li>
          
          <li><a href="../services/elastic/configure.html">Configuring</a></li>
          
          <li><a href="../services/elastic/connecting.html">Connecting Clients</a></li>
          
          <li><a href="../services/elastic/backup_restore.html">Backup and Restore</a></li>
          
          <li><a href="../services/elastic/managing.html">Managing</a></li>
          
          <li><a href="../services/elastic/api-reference.html">API Reference</a></li>
          
          <li><a href="../services/elastic/troubleshooting.html">Troubleshooting</a></li>
          
          <li><a href="../services/elastic/version_policy.html">Version Policy</a></li>
          
          <li><a href="../services/elastic/limitations.html">Limitations</a></li>
          
        </ul>
      </li>
      
      <li>
        
        <span>HDFS</span>
        
        <ul>
          
          
          <li><a href="../services/hdfs/install.html">Install and Customize</a></li>
          
          <li><a href="../services/hdfs/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="../services/hdfs/uninstall.html">Uninstall</a></li>
          
          <li><a href="../services/hdfs/configure.html">Configuring</a></li>
          
          <li><a href="../services/hdfs/connecting-clients.html">Connecting Clients</a></li>
          
          <li><a href="../services/hdfs/managing.html">Managing</a></li>
          
          <li><a href="../services/hdfs/api-reference.html">API Reference</a></li>
          
          <li><a href="../services/hdfs/troubleshooting.html">Troubleshooting</a></li>
          
        </ul>
      </li>
      
      <li>
        
        <span>Kafka</span>
        
        <ul>
          
          
          <li><a href="../services/kafka/quick-start.html">Kick the Tires</a></li>
          
          <li><a href="../services/kafka/install-and-customize.html">Install and Customize</a></li>
          
          <li><a href="../services/kafka/uninstall.html">Uninstall</a></li>
          
          <li><a href="../services/kafka/configure.html">Configure</a></li>
          
          <li><a href="../services/kafka/connecting-clients.html">Connecting Clients</a></li>
          
          <li><a href="../services/kafka/managing.html">Managing</a></li>
          
          <li><a href="../services/kafka/api-reference.html">API Reference</a></li>
          
          <li><a href="../services/kafka/troubleshooting.html">Troubleshooting</a></li>
          
          <li><a href="../services/kafka/version-policy.html">Version Policy</a></li>
          
          <li><a href="../services/kafka/limitations.html">Limitations</a></li>
          
        </ul>
      </li>
      
    </ul>
  </li>
  <li><a href="https://github.com/mesosphere/dcos-commons/blob/master/CONTRIBUTING.md">Contributing</a></li>
  <li><a href="http://chat.dcos.io" target="_blank">Slack</a></li>
</ul>
<h1>Data Store Tutorial</h1>
<div id="content">
<h1 id="overview">Overview</h1>

<p>Mesos is a powerful resource allocator, but writing a production
stateful service can be complex, tedious, and error-prone.  The DC/OS
Stateful Service SDK provides a high-level interface for
writing stateful services.  Now, you can write a stateful service
complete with
persistent volumes, fault tolerance, and configuration management in
about 100 lines of code.  This SDK is the product of Mesosphere’s
experience writing production stateful services such as <a href="https://docs.mesosphere.com/service-docs/kafka/">DC/OS Apache
Kafka</a>
, <a href="https://docs.mesosphere.com/service-docs/cassandra/">DC/OS Apache
Cassandra</a>, and <a href="https://docs.mesosphere.com/service-docs/hdfs/">DC/OS Apache
HDFS</a>.</p>

<p>Read about the <a href="#Features-at-a-glance">features</a> to learn more about
the DC/OS Stateful Service SDK.</p>

<h1 id="introduction">Introduction</h1>

<p>In this tutorial, we’ll build an example
service called <code class="highlighter-rouge">data-store</code>.  It is composed of a small number of
<code class="highlighter-rouge">meta-data</code> nodes and a larger number of <code class="highlighter-rouge">data</code> nodes.  This structure
is meant to model a service with a small number of coordinating master
nodes and a large number of dependent agent nodes.  Each task runs a
command that writes some data to a file, then sleeps.</p>

<p>The goal state for this fictional <code class="highlighter-rouge">data-store</code> is to keep two
<code class="highlighter-rouge">meta-data</code> and N <code class="highlighter-rouge">data</code> nodes running, where, initially, N = 3.
<code class="highlighter-rouge">meta-data</code> nodes must come up before <code class="highlighter-rouge">data</code> nodes.  The service
scales by starting more <code class="highlighter-rouge">data</code> nodes.</p>

<p>This tutorial includes code snippets. The final
source code is available at
<a href="http://github.
com/mesosphere/sdk-reference-framework">http://github.com/mesosphere/sdk-reference-framework</a>.</p>

<h2 id="architecture">Architecture</h2>

<p><img src="../img/data-store-tutorial-architecture.png" alt="DC/OS Service Architecture" /></p>

<p>A DC/OS service is composed of <strong>schedulers</strong> and <strong>executors</strong>.  The
scheduler is run by Marathon, which supervises the scheduler,
restarting it upon failure.  The scheduler, in turn, starts and
supervises the executors.  If specified in the <code class="highlighter-rouge">ServiceSpecification</code>,
the
executors will contain a <strong>persistent volume</strong>, which is a folder or
mount point on the agent that persists even after a task fails. This
allows a stateful service to recover with its data intactafter task
failure or temporary node failure.</p>

<p>In this tutorial, <code class="highlighter-rouge">data-store</code> is the scheduler, and <code class="highlighter-rouge">meta-data-{0,1}</code>
and <code class="highlighter-rouge">data-{0-1}</code> are the executors.</p>

<h2 id="requirements">Requirements</h2>
<ul>
  <li>JDK 8</li>
  <li>Gradle 3.2 (recommended)</li>
  <li>AWS account with S3 upload permissions</li>
  <li><a href="https://aws.amazon.com/cli/"><code class="highlighter-rouge">aws</code> CLI</a></li>
</ul>

<h1 id="create-a-project">Create a Project</h1>

<p>The Java library for The DC/OS Stateful Services SDK is
<code class="highlighter-rouge">dcos-commons</code>.  Java projects using <code class="highlighter-rouge">dcos-commons</code> can use any Java
build system, but for this tutorial, we’ll assume you’re using Gradle.</p>

<p>First, we create our <code class="highlighter-rouge">build.gradle</code> file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>group 'com.mesosphere.sdk'
version '1.0-SNAPSHOT'

apply plugin: 'java'
apply plugin: 'application'

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url "http://downloads.mesosphere.com/maven/"
    }
}

dependencies {
    compile "mesosphere:dcos-commons:0.7.10-SNAPSHOT"
}

task wrapper(type: Wrapper) {
    gradleVersion = '3.2'
}

mainClassName = 'com.mesosphere.sdk.reference.scheduler.Main'
</code></pre>
</div>

<h1 id="define-a-service">Define a Service</h1>

<h2 id="create-a-service-specification">Create a Service Specification</h2>

<p>The first step to running a service is to create a
<code class="highlighter-rouge">ServiceSpecification</code>, which defines the behavior of the service.</p>

<p>A <code class="highlighter-rouge">ServiceSpecification</code> is mostly a list of <code class="highlighter-rouge">TaskSet</code>s.
The tasks defined in this list are launched in order.  We can use this
ordering to define tiers of services.  In this example, we want all
<code class="highlighter-rouge">meta-data</code> nodes to come up before any <code class="highlighter-rouge">data</code> node:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_METADATA_NAME</span> <span class="o">=</span> <span class="s">"meta-data"</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TASK_METADATA_COUNT</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"METADATA_COUNT"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_METADATA_CPU</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"METADATA_CPU"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_METADATA_MEM_MB</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"METADATA_MEM"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_METADATA_DISK_MB</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"METADATA_DISK"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_METADATA_URI</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"METADATA_URI"</span><span class="o">);</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_METADATA_CMD</span> <span class="o">=</span> <span class="s">"bash meta-data"</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_DATA_NAME</span> <span class="o">=</span> <span class="s">"data"</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TASK_DATA_COUNT</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"DATA_COUNT"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_DATA_CPU</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"DATA_CPU"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_DATA_MEM_MB</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"DATA_MEM"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">TASK_DATA_DISK_MB</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"DATA_DISK"</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_DATA_URI</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"DATA_URI"</span><span class="o">);</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TASK_DATA_CMD</span> <span class="o">=</span> <span class="s">"bash data"</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="n">ServiceSpecification</span> <span class="nf">getServiceSpecification</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ServiceSpecification</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">SERVICE_NAME</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TaskSet</span><span class="o">&gt;</span> <span class="nf">getTaskSets</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
                    <span class="n">DefaultTaskSet</span><span class="o">.</span><span class="na">create</span><span class="o">(</span>
                            <span class="n">TASK_METADATA_COUNT</span><span class="o">,</span>
                            <span class="n">TASK_METADATA_NAME</span><span class="o">,</span>
                            <span class="n">getCommand</span><span class="o">(</span><span class="n">TASK_METADATA_CMD</span><span class="o">,</span> <span class="n">TASK_METADATA_URI</span><span class="o">),</span>
                            <span class="n">getResources</span><span class="o">(</span><span class="n">TASK_METADATA_CPU</span><span class="o">,</span> <span class="n">TASK_METADATA_MEM_MB</span><span class="o">),</span>
                            <span class="n">getVolumes</span><span class="o">(</span><span class="n">TASK_METADATA_DISK_MB</span><span class="o">,</span> <span class="n">TASK_METADATA_NAME</span><span class="o">),</span>
                            <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">TaskTypeGenerator</span><span class="o">.</span><span class="na">createAvoid</span><span class="o">(</span><span class="n">TASK_METADATA_NAME</span><span class="o">)),</span>
                            <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">getHealthCheck</span><span class="o">(</span><span class="n">TASK_METADATA_NAME</span><span class="o">))),</span>
                    <span class="n">DefaultTaskSet</span><span class="o">.</span><span class="na">create</span><span class="o">(</span>
                            <span class="n">TASK_DATA_COUNT</span><span class="o">,</span>
                            <span class="n">TASK_DATA_NAME</span><span class="o">,</span>
                            <span class="n">getCommand</span><span class="o">(</span><span class="n">TASK_DATA_CMD</span><span class="o">,</span> <span class="n">TASK_DATA_URI</span><span class="o">),</span>
                            <span class="n">getResources</span><span class="o">(</span><span class="n">TASK_DATA_CPU</span><span class="o">,</span> <span class="n">TASK_DATA_MEM_MB</span><span class="o">),</span>
                            <span class="n">getVolumes</span><span class="o">(</span><span class="n">TASK_DATA_DISK_MB</span><span class="o">,</span> <span class="n">TASK_DATA_NAME</span><span class="o">),</span>
                            <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">TaskTypeGenerator</span><span class="o">.</span><span class="na">createAvoid</span><span class="o">(</span><span class="n">TASK_DATA_NAME</span><span class="o">)),</span>
                            <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">getHealthCheck</span><span class="o">(</span><span class="n">TASK_DATA_NAME</span><span class="o">))));</span>
        <span class="o">}</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre>
</div>

<p>A <code class="highlighter-rouge">TaskSet</code> contains the bulk of the definition.  It
contains the command to run, the resources to run with, and the number
of tasks.  As you can see, it is common for DC/OS services to read
their config from environment variables.</p>

<p>At a minimum, the command must contain a <code class="highlighter-rouge">value</code>, which is the shell
command to invoke.  It will likely also contain one or more <code class="highlighter-rouge">URIs</code>
pointing to resources to download before execution.  In this example,
we’re downloading the <code class="highlighter-rouge">metadata</code> and <code class="highlighter-rouge">data</code> binaries from an HTTP
server:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Protos</span><span class="o">.</span><span class="na">CommandInfo</span> <span class="nf">getCommand</span><span class="o">(</span><span class="n">String</span> <span class="n">cmd</span><span class="o">,</span> <span class="n">String</span> <span class="n">uri</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Protos</span><span class="o">.</span><span class="na">CommandInfo</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
              <span class="o">.</span><span class="na">addUris</span><span class="o">(</span><span class="n">Protos</span><span class="o">.</span><span class="na">CommandInfo</span><span class="o">.</span><span class="na">URI</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">setValue</span><span class="o">(</span><span class="n">uri</span><span class="o">))</span>
              <span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">cmd</span><span class="o">)</span>
              <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Resurces are specified via <code class="highlighter-rouge">ResourceSpecification</code>s.  Tasks must run
with at least <code class="highlighter-rouge">cpus</code> and <code class="highlighter-rouge">mem</code> resources, though we may specify any
Mesos resource, including <code class="highlighter-rouge">ports</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">ResourceSpecification</span><span class="o">&gt;</span> <span class="nf">getResources</span><span class="o">(</span><span class="kt">double</span> <span class="n">cpu</span><span class="o">,</span> <span class="kt">double</span> <span class="n">memMb</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
            <span class="k">new</span> <span class="nf">DefaultResourceSpecification</span><span class="o">(</span>
                    <span class="s">"cpus"</span><span class="o">,</span>
                    <span class="n">ValueUtils</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ResourceUtils</span><span class="o">.</span><span class="na">getUnreservedScalar</span><span class="o">(</span><span class="s">"cpus"</span><span class="o">,</span> <span class="n">cpu</span><span class="o">)),</span>
                    <span class="n">ROLE</span><span class="o">,</span>
                    <span class="n">PRINCIPAL</span><span class="o">),</span>
            <span class="k">new</span> <span class="nf">DefaultResourceSpecification</span><span class="o">(</span>
                    <span class="s">"mem"</span><span class="o">,</span>
                    <span class="n">ValueUtils</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ResourceUtils</span><span class="o">.</span><span class="na">getUnreservedScalar</span><span class="o">(</span><span class="s">"mem"</span><span class="o">,</span> <span class="n">memMb</span><span class="o">)),</span>
                    <span class="n">ROLE</span><span class="o">,</span>
                    <span class="n">PRINCIPAL</span><span class="o">));</span>
<span class="o">}</span>
</code></pre>
</div>

<p>In Mesos, <code class="highlighter-rouge">disk</code> is just another resource, like <code class="highlighter-rouge">cpus</code> and <code class="highlighter-rouge">mem</code>.
However, stateful services must manage <code class="highlighter-rouge">disk</code> differently.  Rather
than simply accepting the resource like <code class="highlighter-rouge">cpus</code> or <code class="highlighter-rouge">mem</code>, the scheduler
must first create a
<a href="http://mesos.apache.org/documentation/latest/persistent-
volume/">volume</a>
from the disk resources so that it persists beyond the lifetime of the
task.  The <code class="highlighter-rouge">VolumeSpecification</code> is a high-level interface that
handles this for us:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">VolumeSpecification</span><span class="o">&gt;</span> <span class="nf">getVolumes</span><span class="o">(</span><span class="kt">double</span> <span class="n">diskMb</span><span class="o">,</span> <span class="n">String</span> <span class="n">taskName</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">VolumeSpecification</span> <span class="n">volumeSpecification</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultVolumeSpecification</span><span class="o">(</span>
            <span class="n">diskMb</span><span class="o">,</span>
            <span class="n">VolumeSpecification</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">ROOT</span><span class="o">,</span>
            <span class="n">taskName</span> <span class="o">+</span> <span class="n">CONTAINER_PATH_SUFFIX</span><span class="o">,</span>
            <span class="n">ROLE</span><span class="o">,</span>
            <span class="n">PRINCIPAL</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">volumeSpecification</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Finally, we can attach a health check to our tasks.  If the check
fails, the Mesos agent will kill the task, and the scheduler will
restart it.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">Protos</span><span class="o">.</span><span class="na">HealthCheck</span> <span class="nf">getHealthCheck</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Protos</span><span class="o">.</span><span class="na">CommandInfo</span> <span class="n">commandInfo</span> <span class="o">=</span> <span class="n">Protos</span><span class="o">.</span><span class="na">CommandInfo</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">"stat %s%s/output"</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">CONTAINER_PATH_SUFFIX</span><span class="o">))</span>
        <span class="o">.</span><span class="na">build</span><span class="o">()</span>

    <span class="k">return</span> <span class="n">Protos</span><span class="o">.</span><span class="na">HealthCheck</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">setCommand</span><span class="o">(</span><span class="n">commandInfo</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="define-a-main-class">Define a Main Class</h2>

<p>Now that we have a <code class="highlighter-rouge">ServiceSpecification</code>, we must define a Main class
that runs it.  To do this, create a <code class="highlighter-rouge">Service</code> object, and register the
<code class="highlighter-rouge">ServiceSpecification</code> with it:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">API_PORT</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"PORT0"</span><span class="o">));</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">DefaultService</span><span class="o">(</span><span class="n">API_PORT</span><span class="o">).</span><span class="na">register</span><span class="o">(</span><span class="n">getServiceSpecification</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">DefaultService</code> takes a single parameter, <code class="highlighter-rouge">apiPort</code>. <code class="highlighter-rouge">apiPort</code>
specifies which
port its HTTP server will bind to.  Upon registering the
<code class="highlighter-rouge">ServiceSpecification</code>, our service will start its HTTP server,
register as a Mesos framework, and start launching tasks.</p>

<h1 id="deployment">Deployment</h1>

<p>Now that we’ve defined our service, let’s build and install it.  The
first thing we’ll need is a DC/OS cluster.</p>

<h2 id="start-cluster">Start cluster</h2>

<p>Go to <a href="https://dcos.io/install/">https://dcos.io/install/</a> to install
a DC/OS cluster.</p>

<h2 id="install-the-dcos-cli">Install the DC/OS CLI</h2>

<p>If you have not already installed the CLI, do so by following <a href="https://dcos.io/docs/1.9/cli/install/">these
instructions</a>.</p>

<h2 id="install">Install</h2>

<p>Now that we have our cluster and CLI, we can install our service.
DC/OS services are deployed to users via DC/OS packages.  The first
step is to define our package.</p>

<h3 id="define-a-dcos-package">Define a DC/OS Package</h3>

<p>A DC/OS package is a set of four
files.  You can learn more about the package format
<a href="http://github.com/mesosphere/universe">here</a>, but, in summary, it
looks like this:</p>

<ul>
  <li><strong>package.json</strong>: Package metadata</li>
  <li><strong>marathon.json.mustache</strong>: Marathon app definition.  The template
is rendered with the values in config.json, resource.json,
and user-provided config.</li>
  <li><strong>config.json</strong>: JSON Schema defining the configuration for the app.</li>
  <li><strong>resource.json</strong>: External resources.</li>
</ul>

<p>The majority of the package definition resides in
<strong>marathon.json.mustache</strong>.  See the
<a href="https://github.com/mesosphere/sdk-reference-framework/tree/
master/universe">reference
framework</a>
for an example.</p>

<p>Let’s place these files in a directory in our project called
<code class="highlighter-rouge">universe/</code>.</p>

<p>Now we build our project:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>./gradlew distZip
</code></pre>
</div>

<h3 id="build-a-dcos-package">Build a DC/OS Package</h3>

<p>Then we must build our DC/OS package.  DC/OS packages are stored in
<em>repos</em>.  The most common repo is the
<a href="https://github.com/mesosphere/universe"><em>Mesosphere Universe</em></a>, which
is public. We would publish our package there if we wished to
share it with the world.  For now, we just want to create a simple
repo containing our single package.</p>

<p><strong>NOTE:</strong> The current workflow of creating a package <em>and</em> a repo is
  cumbersome.  We’re sorry about this.  DC/OS 1.10, which is slated to
  be released in December 2016, will introduce the ability to install
  a package directly, rather than forcing you to wrap it in a repo.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>~ <span class="nv">$ </span><span class="nb">cd</span> /path/to/dcos-commons
dcos-commons <span class="nv">$ </span>./tools/publish_aws.py <span class="se">\</span>
      data-store <span class="se">\</span>
      universe/ <span class="se">\</span>
      reference-scheduler/build/distributions/scheduler.zip
</code></pre>
</div>

<p><code class="highlighter-rouge">./publish_aws.py</code> uploads the artifact to S3, rewrites the package to
include links to the artifact, creates a repo containing that package,
and uploads that repo to S3.  The end result is a URL for a DC/OS
repo.</p>

<p>We now add the repo URL printed by <code class="highlighter-rouge">publish_aws.py</code> to our cluster:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dcos package repo add --index<span class="o">=</span>0 dev-repo &lt;repo_url&gt;
</code></pre>
</div>

<p>Then, install our package:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dcos package install data-store
</code></pre>
</div>

<p>Visit <strong>Services</strong> &gt; <strong>data-store</strong> in the DC/OS UI to watch
<code class="highlighter-rouge">data-store</code> deploying.</p>

<p>To verify that <code class="highlighter-rouge">data-store</code> has completed deploying, make the
following HTTP request from the DC/OS CLI. To learn how to make
requests to the HTTP API,
please read the <a href="#http-api">HTTP API</a> section:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GET /v1/plan/status
</code></pre>
</div>

<p>This HTTP request will return JSON to indicate the status of the
service. If the deployment is complete, <code class="highlighter-rouge">plan.status</code> will equal
“COMPLETE”.</p>

<p>When deployment is complete, two <code class="highlighter-rouge">meta-data</code>
tasks and three <code class="highlighter-rouge">data</code> tasks will be visible in the DC/OS Services UI.</p>

<h2 id="uninstall">Uninstall</h2>

<p>To do a complete uninstall, we first uninstall our service using the
DC/OS CLI.  This stops and tears down the framework.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dcos package uninstall data-store
</code></pre>
</div>

<p>However, uninstalling the package does not remove persistent state
like Zookeeper state and persistent volumes. Mesosphere provides a
Docker image to remove persistent state:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">local</span> <span class="nv">$ AUTH_TOKEN</span><span class="o">=</span><span class="k">$(</span>dcos config show core.dcos_acs_token<span class="k">)</span>
<span class="nb">local</span> <span class="nv">$ </span>dcos node ssh --master-proxy --leader
cluster <span class="nv">$ </span>docker run mesosphere/janitor /janitor.py <span class="se">\</span>
    -r data-store-role <span class="se">\</span>
    -p data-store-principal <span class="se">\</span>
    -z dcos-service-data-store <span class="se">\</span>
    --auth_token<span class="o">=</span><span class="nv">$AUTH_TOKEN</span>
</code></pre>
</div>

<p>For more information on the janitor image, see
https://github.com/mesosphere/framework-cleaner.</p>

<h1 id="plan-management">Plan management</h1>
<p>As noted earlier, stateful services often have particular deployment
requirements.  These deployments may involve the initial creation of
Tasks or a change in Task configuration or the scaling of a
particular kind of task or an upgrade to a new version of a Task.  Each
of these scenarios comes with attendant risks and benefits.  In some
cases (as in initial install) you may be happy to have a service rollout
without intervention.  In others, as in a configuration update, one may
wish to deploy some portion of a service and check stability before
completing a deployment.</p>

<p>In order to provide the necessary flexibility and control necessary to
achieve these outcomes, the SDK organizes deployment of tasks by means
of Plans. Plans are composed of Phases which are composed of Blocks.
A Block encapsulates the smallest element of work executed in a Plan and
is the plan element which encapsulates the launching of Mesos Tasks.</p>

<p>Phases are groups of Blocks which have some semantic relationship.  At
least two plans are generated automatically by the SDK when presented
with a <code class="highlighter-rouge">ServiceSpecification</code>.  These are the deployment and recovery
plans.  The deployment plan is concerned with deploying Tasks.  It
deploys Tasks for the first time, and when configuration updates are
indicated by a user.  The recovery plan is concerned with defining the
necessary operations which must be performed when transient or permanent
failures are encountered.</p>

<p>Let us examine the deployment plan of the example data-store service
after its initial installation has completed.</p>

<p>Executing the following command:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GET /v1/plan"
</code></pre>
</div>

<p>generates the following output:</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nt">"phases"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
		</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"31a3ca99-bdbd-45dd-a8f0-cc93feade61e"</span><span class="p">,</span><span class="w">
		</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"meta-data"</span><span class="p">,</span><span class="w">
		</span><span class="nt">"blocks"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
			</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2a0db529-095b-4b63-8c56-075aa442c898"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"meta-data-0"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Block: meta-data-0"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"has_decision_point"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
		</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
			</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"99210582-cdfb-4b63-95e9-19600f117dc7"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"meta-data-1"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Block: meta-data-1"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"has_decision_point"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
		</span><span class="p">}],</span><span class="w">
		</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
	</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"927ac279-b969-4106-9089-40264ae15dc4"</span><span class="p">,</span><span class="w">
		</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data"</span><span class="p">,</span><span class="w">
		</span><span class="nt">"blocks"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
			</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"efcf9dc0-488f-4f9e-ae0c-1ac16c401e0a"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data-0"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Block: data-0"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"has_decision_point"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
		</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
			</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"a0e0905b-d4da-4cec-84b9-461a60a92818"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data-1"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Block: data-1"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"has_decision_point"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
		</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
			</span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"fa85a843-e6eb-4074-b353-875197a18adb"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data-2"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Block: data-2"</span><span class="p">,</span><span class="w">
			</span><span class="nt">"has_decision_point"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
		</span><span class="p">}],</span><span class="w">
		</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
	</span><span class="p">}],</span><span class="w">
	</span><span class="nt">"errors"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
	</span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>The first thing to notice is that the <code class="highlighter-rouge">TaskSet</code>s defined in a
<code class="highlighter-rouge">ServiceSpecification</code> are mapped to deployment Phases. The data-store
example service has <code class="highlighter-rouge">TaskSet</code>s encapsulating <code class="highlighter-rouge">meta-data</code> and <code class="highlighter-rouge">data</code>
Tasks in that order.  The deployment plan above has the respective
<code class="highlighter-rouge">meta-data</code> and <code class="highlighter-rouge">data</code> Phases.</p>

<p>In its default configuration, the two <code class="highlighter-rouge">meta-data</code> Tasks and three <code class="highlighter-rouge">data</code>
Tasks are launched.  We can see that a Block has been created
encapsulating each of those tasks.  The names of Blocks map to the names
of the <code class="highlighter-rouge">TaskSpecification</code> objects within a <code class="highlighter-rouge">TaskSet</code>.  The status of a
Block can be in one of 3 states.  It may be <code class="highlighter-rouge">PENDING</code>, <code class="highlighter-rouge">IN_PROGRESS</code>, or
<code class="highlighter-rouge">COMPLETE</code>.</p>

<p>By default all Phases and the Blocks within them are rolled out
serially.  Each Block must reach a <code class="highlighter-rouge">COMPLETE</code> state before the
next Block may be started.  Beyond this automatic behavior, it is often
desirable to manually pause/resume a deployment.  For example, in a
production setting multiple uncoordinated deployments may cause
unexpected effects, including causing unavailability or severely
degraded performance.  In thes cases and others, the ability to pause
individual deployments while others continue without performing a full
rollback can be helpful.</p>

<p>The <code class="highlighter-rouge">has_decision_point</code> fields above indicate whether a user has indicated
a desire to pause a deployment at a particular Block.</p>

<p>A Plan’s execution may be paused or continued by POST commands executed
against the HTTP endpoints at the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L53"><code class="highlighter-rouge">/v1/plan/interrupt</code></a>
and <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L46"><code class="highlighter-rouge">/v1/plan/continue</code></a>
respectively.  For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>POST /v1/plan/interrupt"
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>POST /v1/plan/continue"
</code></pre>
</div>

<p>Finally, beyond manual control of Plan execution behavior it may be
desirable in certain failure scenarios to either restart the execution
of a Block or force its completion.  Restarting a Block in default
implementations simply sets a Block’s status to <code class="highlighter-rouge">PENDING</code> and allows the
normal Block processing system to do the necessary work to drive a Block
to completion.  This can be accomplished by issuing a POST command to
the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L69"><code class="highlighter-rouge">/v1/plan/restart</code></a>
endpoint.  For example to restart the Block associated with the first
data task <code class="highlighter-rouge">data-0</code> one would issue the following command:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>POST /v1/plan/restart?phase<span class="o">=</span>927ac279-b969-4106-9089-40264ae15dc4&amp;block<span class="o">=</span>efcf9dc0-488f-4f9e-ae0c-1ac16c401e0a<span class="s2">"
</span></code></pre>
</div>

<p>Forcing the completion of a block can be accomplished in a similar
manner by issuing a POST command against the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L69"><code class="highlighter-rouge">/v1/plan/forceComplete</code></a>
endpoint. For example to force the completion of the second <code class="highlighter-rouge">meta-data</code>
block one would issue the following command:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>POST /v1/plan/forceComplete?phase<span class="o">=</span>31a3ca99-bdbd-45dd-a8f0-cc93feade61&amp;block<span class="o">=</span>99210582-cdfb-4b63-95e9-19600f117dc7<span class="s2">"
</span></code></pre>
</div>

<h1 id="update-configuration">Update configuration</h1>

<p>We saw in the <a href="#create-a-service-specification">Service Specification
section</a> that the service’s
configuration is read in through environment variables.  You can use
any source of configuration, but DC/OS Services are typically
configured through environment variables.  To make a configuration
change, modify the corresponding environment variable,
then restart the scheduler.  When the scheduler comes back up, it will
read its new configuration and transition to the new state.</p>

<p>For example, in order to scale the <code class="highlighter-rouge">data-store</code> service from 3 <code class="highlighter-rouge">data</code>
nodes to 5, modify the <code class="highlighter-rouge">DATA_COUNT</code> environment variable. To modify
it:</p>

<p>1) Go the the <strong>Services</strong> &gt; <strong>data-store</strong> page of the DC/OS UI.</p>

<p>1) Click <strong>Edit</strong>.</p>

<p>1) Click the <strong>Environment Variables</strong> tab.</p>

<p>1) Change the value of <code class="highlighter-rouge">DATA_COUNT</code> from 3 to 5.</p>

<p>1) Click <strong>Deploy Changes</strong>.</p>

<p>This will restart the scheduler with the updated environment.  When
the scheduler starts up, it detects that it is already running 3
<code class="highlighter-rouge">data</code> tasks and starts 2 more in order to reach the goal state of 5.
We should observe two more tasks starting, <code class="highlighter-rouge">data-3</code> and <code class="highlighter-rouge">data-4</code>.</p>

<h2 id="task-configuration-management">Task Configuration management</h2>

<p>While the above describes configuration of the scheduler itself via
environment variables, there’s also a need for configuration of the
underlying service tasks themselves in a flexible way.</p>

<p>To simplify the common task of getting user-facing configuration to
service tasks, the developer may follow the following convention in
naming the environment variables for these configuration options:
<code class="highlighter-rouge">TASKCFG_&lt;TASK_TYPE&gt;_&lt;CFGNAME&gt;</code>, where <code class="highlighter-rouge">&lt;TASK_TYPE&gt;</code> has been
converted from the task type to fit the requirements of environment
variables:</p>

<ul>
  <li>Uppercased</li>
  <li>Non-alphanumeric characters (punctuation, whitespace) converted
to underscores</li>
</ul>

<p>For example, an option named <code class="highlighter-rouge">FOO</code> for tasks of type <code class="highlighter-rouge">index.mgr</code>
should be named <code class="highlighter-rouge">TASKCFG_INDEX_MGR_FOO</code>, while an option <code class="highlighter-rouge">BAR</code> for
tasks of type <code class="highlighter-rouge">data-node</code> should be named <code class="highlighter-rouge">TASKCFG_DATA_NODE_BAR</code>.
These configuration options will automatically be forwarded to the
environments of the matching tasks as environment variables, with
the <code class="highlighter-rouge">TASKCFG_&lt;TASK_TYPE&gt;_</code> prefixes removed. A special prefix of
<code class="highlighter-rouge">TASKCFG_ALL_&lt;NAME&gt;</code> may be used for any options that should be
passed to <em>every</em> task type.</p>

<p>A common need for service developers is an easy way to write
configuration files before launching tasks. To fulfill this need,
the developer may provide configuration file template(s) in their
TaskSet(s). These templates follow the <a href="https://mustache.github.io/">mustache</a>
templating format, similar to what’s used in DC/OS packaging. The
templates will be automatically rendered against the task’s
environment (which is customized as described above), and then
each written to relative file paths specified by the developer.</p>

<h1 id="restart-tasks">Restart tasks</h1>

<p>When a task fails, the scheduler will attempt to restart the on the
same node, using the same persistent volume as the previous task.</p>

<p>There are two cases where you must manually restart tasks:</p>

<p>1) If an agent permanently fails or is failing, the scheduler will
never receive an
offer with the expected persistent volume, and will thus never
automatically restart the task.  We must restart it manually on a
different node.  This is called <em>replacing</em> the task.</p>

<p>2) If a task is stuck or performing poorly, or we just want to restart
it for debugging, we may need to restart the task manually on the same
node.</p>

<p>You can perform both actions using the same endpoint:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>POST /v1/tasks/restart/&lt;task-name&gt;?replace={true|false}
</code></pre>
</div>

<p>If <code class="highlighter-rouge">replace=true</code>, this action will replace the task on a separate
node.  If <code class="highlighter-rouge">replace=false</code>, it will restart the task on the same node.</p>

<h1 id="placement">Placement</h1>

<p>The <code class="highlighter-rouge">DefaultScheduler</code> makes no intelligent placement decisions.  It
will run a task on first offer it gets that satisfies the resource
constraints for that task.</p>

<p>Placement decisions may be customized using <em>Placement Constraints</em>,
which
are rules that specify how tasks should be placed in the cluster.
These rules
are enforced by filtering the resource offers returned by Mesos.
Resources that do not conform to the rules are removed from the list.</p>

<p>You can define placement constraints on a
per-task basis by customizing the return value of
<code class="highlighter-rouge">TaskSpecification.getPlacement()</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public Optional&lt;PlacementRuleGenerator&gt; getPlacement() {
    // avoid systems which are running an "index" task:
    return Optional.of(TaskTypeGenerator.createAvoid("index"));
}
</code></pre>
</div>

<p>You can use some of the common <code class="highlighter-rouge">PlacementRule</code>s
and/or <code class="highlighter-rouge">PlacementRuleGenerator</code> implementations provided in the
<a href="https://github.com/mesosphere/dcos-commons/tree/
master/src/main/java/org/apache/mesos/offer/constrain">offer.constrain</a>
package. You can also create your own <code class="highlighter-rouge">PlacementRule</code>s for custom
constraints. Custom constraints can take advantage of anything present
in the Mesos <code class="highlighter-rouge">Offers</code>
or in the other running <code class="highlighter-rouge">TaskInfo</code>s.</p>

<h1 id="logs">Logs</h1>

<p>The <code class="highlighter-rouge">stdout</code> and <code class="highlighter-rouge">stderr</code> streams for all tasks running in Mesos,
including the scheduler and executors, are captured and written to
files in that task’s sandbox. You can view these files from the
<strong>Services</strong> tab of the DC/OS UI or from the CLI. <a href="https://docs.mesosphere.com/1.9/monitoring/logging/">Learn
more</a>.</p>

<p>All code in <code class="highlighter-rouge">dcos-commons</code>, including the <code class="highlighter-rouge">DefaultScheduler</code>, uses
<code class="highlighter-rouge">slf4j</code> to write logs to <code class="highlighter-rouge">stderr</code>.  To write your own logging code,
first create a <code class="highlighter-rouge">LOGGER</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOGGER</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre>
</div>

<p>Then write to it:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Starting reference scheduler with args: "</span> <span class="o">+</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">args</span><span class="o">));</span>
</code></pre>
</div>

<p>The contents of <code class="highlighter-rouge">stdout</code> and <code class="highlighter-rouge">stderr</code> for the executors is entirely
dependent on the command specified in our <code class="highlighter-rouge">ServiceSpecification</code>.</p>

<h1 id="tests">Tests</h1>

<h2 id="unit-tests">Unit Tests</h2>

<p><code class="highlighter-rouge">dcos-commons</code> contains unit
tests written with <code class="highlighter-rouge">junit</code> and <code class="highlighter-rouge">mockito</code>. You can also create your own
unit tests.</p>

<h2 id="integration-tests">Integration Tests</h2>

<p>The <a href="https://github.com/dcos/shakedown">shakedown</a> library is a tool for
writing integration tests for DC/OS services.  For an example, see
<a href="https://github.com/mesosphere/dcos-kafka-service/tree/master/integration/tests">the tests for DC/OS
Kafka</a>.</p>

<h1 id="metrics">Metrics</h1>

<p>As of DC/OS 1.8, this section is only relevant to DC/OS Enterprise
Edition, but support has recently been
<a href="http://github.com/dcos/dcos-metrics">open-sourced</a>
and should soon be available in Open DC/OS. For more information,
see the <a href="http://github.com/dcos/dcos-metrics">dcos-metrics</a>
repository and stop by the #day2ops channel on <a href="http://chat.dcos.io">DC/OS
Slack</a>.</p>

<p>DC/OS Metrics automatically provides all Mesos containers with a
unique UDP endpoint for outputting <code class="highlighter-rouge">statsd</code>-formatted metrics. The
endpoint
is advertised via two container environment variables:
<code class="highlighter-rouge">STATSD_UDP_HOST</code>
and <code class="highlighter-rouge">STATSD_UDP_PORT</code>. Any metrics sent to this advertised endpoint
will automatically be tagged with the originating container and
forwarded upstream to the cluster’s metrics infrastructure.</p>

<p>You can take advantage of this endpoint for your service
scheduler as well as for the underlying service tasks themselves. For
instance, you can configure your service’s tasks to emit to the
locally-advertised endpoint as they are launched.</p>

<p><strong>Note:</strong> The environment-advertised endpoint is
unique to each container and cannot be reused across containers.</p>

<p>The data sent to this endpoint should follow the standard <code class="highlighter-rouge">statsd</code>
text format, optionally with multiple newline-separated values
per UDP packet.
<a href="Datadog-
extension">http://docs.datadoghq.com/guides/dogstatsd/#datagram-format</a>
tags are also supported, so the application may also include its own
custom tags:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>memory.usage_mb:5|g
frontend.query.latency_ms:46|g|#shard_id:6,section:frontpage
</code></pre>
</div>

<p>See also:</p>
<ul>
  <li><a href="https://github.com/dcos/dcos-metrics">dcos-metrics repo</a></li>
  <li><a href="https://github.com/dcos/dcos-metrics/tree/master/examples/
statsd-emitter">Sample StatsD emitter
process</a></li>
  <li><a href="https://github.com/mesosphere/dcos-kafka-service/blob/
30acc60676ba9362ddb9b74f208b36d257a78f93/kafka-config-overrider/src/
main/java/com/mesosphere/dcos/kafka/config/Overrider.java#L163">Metrics configuration for
Kafka</a></li>
  <li><a href="https://github.com/mesosphere/dcos-cassandra-service/blob/
38360f9f78d7063824ad77f9871108fe5609e54d/cassandra-executor/src/main/
java/com/mesosphere/dcos/cassandra/executor/metrics/MetricsConfig.java
#L68">Metrics configuration for
Cassandra</a></li>
</ul>

<h1 id="service-discovery">Service Discovery</h1>

<p>Mesos-DNS assigns every Mesos task a DNS address of the form
<code class="highlighter-rouge">&lt;task-name&gt;.&lt;framework-name&gt;.mesos</code>.  In our example (running 3 data
nodes), Mesos-DNS creates the following addresses:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>meta-data-0.data-store.mesos
meta-data-1.data-store.mesos
meta-data-2.data-store.mesos
data-0.data-store.mesos
data-1.data-store.mesos
</code></pre>
</div>

<p>It also creates a DNS entry for the scheduler:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data-store.marathon.mesos
</code></pre>
</div>

<p>If the tasks listen on reserved port(s), clients will also need
these port(s) in order to establish a connection.  We can fetch these
port(s) along with the DNS entry for a task via the following
endpoint:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>GET /v1/tasks/connection/<span class="o">{</span>task-name<span class="o">}</span>
</code></pre>
</div>

<p>This HTTP request returns:</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"dns"</span><span class="p">:</span><span class="w"> </span><span class="s2">"data-0.data-store.mesos"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"ports"</span><span class="p">:</span><span class="w"> </span><span class="s2">"4388"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>If the task has multiple ports reserved, they will be displayed as a
comma-delimited sequence of ranges. e.g. <code class="highlighter-rouge">"8080,2000-3000"</code>.</p>

<h1 id="secrets-management">Secrets Management</h1>

<p>This section is only relevant to DC/OS Enterprise Edition.</p>

<p>In a DC/OS Enterprise Edition cluster running in strict security mode,
all schedulers must authenticate with the Mesos master using DC/OS
service accounts.  For instructions on creating a service account,
read
[this][https://docs.mesosphere.com/1.9/security/service-auth/]</p>

<p>Mesos schedulers authenticate to the master by providing a <code class="highlighter-rouge">principal</code>
and <code class="highlighter-rouge">secret</code>.  In DC/OS, the <code class="highlighter-rouge">principal</code> must be the DC/OS Service
Account ID, and the <code class="highlighter-rouge">secret</code> must be the private key.  To start the
scheduler with access to the private key, we must integrate with
Marathon’s DC/OS secret support:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="s2">"env"</span><span class="err">:</span> <span class="p">{</span>
    <span class="s2">"DCOS_SERVICE_ACCOUNT_CREDENTIAL"</span><span class="err">:</span> <span class="p">{</span><span class="s2">"secret"</span><span class="err">:</span> <span class="s2">"serviceCredential"</span><span class="p">}</span>
  <span class="p">},</span>
  <span class="s2">"secrets"</span><span class="err">:</span> <span class="p">{</span>
    <span class="s2">"serviceCredential"</span><span class="err">:</span> <span class="p">{</span>
      <span class="s2">"source"</span><span class="err">:</span> <span class="o">&lt;</span><span class="nx">secret_name</span><span class="o">&gt;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This causes Marathon to launch the task with the
<code class="highlighter-rouge">DCOS_SERVICE_ACCOUNT_CREDENTIAL</code> environment variable set to the
contents of the service account’s private key.  The Mesos agent looks
for this environment variable and will inject it as the <code class="highlighter-rouge">secret</code> in
the scheduler’s registration request.</p>

<h1 id="http-api">HTTP API</h1>

<p>Services expose an HTTP API to support common operations.  There are
two ways to access this API.</p>

<p>The first is from clients running outside of DC/OS, such as from your
local machine.  These clients must authenticate.  For example:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>curl -H <span class="s2">"Authorization: token=</span><span class="k">$(</span>dcos config show core.dcos_acs_token<span class="k">)</span><span class="s2">"</span> <span class="se">\</span>
    <span class="s2">"</span><span class="k">$(</span>dcos config show core.dcos_url<span class="k">)</span><span class="s2">/service/data-store/v1/plan/status"</span>
</code></pre>
</div>

<p>To learn more about DC/OS Authentication, visit the
[Managing
Authentication](https://dcos.io/docs/1.9/security/managing-authentication/
section of the DC/OS documentation.</p>

<p>The second way to access the HTTP API is from clients running inside
the
DC/OS cluster.  These clients may bypass DC/OS authentication and
access the scheduler directly:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>curl <span class="s2">"data-store.marathon.mesos:&lt;port&gt;/v1/plan/status"</span>
</code></pre>
</div>

<p>Where <port> is the port you gave to the `DefaultService` constructor
in the [Define a Service](#define-a-service) section.</port></p>

<p>Several API endpoints are listed in this tutorial and a full API is
forthcoming.</p>

<h1 id="features-at-a-glance">Features at-a-glance</h1>

<ul>
  <li>
    <p><strong>Simple service definitions</strong> - A simple, declarative API to
simplify resource offer configuration. <a href="#simple-service-definitions">Learn
more</a>.</p>
  </li>
  <li>
    <p><strong>Multi-tier service support</strong> - A scheduler created with the DC/OS
Stateful Services SDK is aware of dependencies between tiers of
processes, enabling one-click install and safe failure recovery.
<a href="#multi-tier-service-support">Learn more</a>.</p>
  </li>
  <li>
    <p><strong>Deployment strategies</strong> - The DC/OS Stateful Services SDK supports
diverse deployment strategies to fit the needs of schedulers. <a href="#deployment-strategies">Learn
more</a>.</p>
  </li>
  <li>
    <p><strong>Configuration management</strong> - The DC/OS Stateful Services SDK can
read
configuration from an external source, detect configuration
modifications, and control which configurations can be modified by the
user. <a href="#configuration-management">Learn more</a>.</p>
  </li>
  <li>
    <p><strong>Interactive upgrade support</strong> - You can pause, continue, or abort
an upgrade interactively in order to upgrade tasks safely. <a href="#interactive-upgrade-support">Learn
more</a>.</p>
  </li>
  <li>
    <p><strong>Fault tolerance</strong> - Schedulers built with the SDK are
automatically configured to detect and
restart failed tasks on the same node (to preserve state) and, if the
node fails, restart it on a different node. <a href="#fault-tolerance">Learn
more</a>.</p>
  </li>
  <li>
    <p><strong>Persistent volumes</strong> - The SDK automatically configures your
scheduler to
create persistent volumes, enabling stateful tasks. <a href="#persistent-volumes">Learn
more</a>.</p>
  </li>
</ul>

<h1 id="features-in-depth">Features in-depth</h1>

<h2 id="simple-service-definitions">Simple service definitions</h2>
<p>Mesos offers resources to the scheduler for launching tasks rather
than launching tasks against a fixed API. Resource offers are more
powerful and flexible than a declarative task launching API because
schedulers can apply arbitrary logic to determine the set of resources
they consume.</p>

<p>However, the majority of schedulers, especially schedulers for
stateful services, only need a basic API. For these cases,
declarative APIs are much simpler.  A simple scheduler only needs to
run N containers with M memory and C cpu, along with some set of
persistent volumes, ports, etc.</p>

<p>For these cases, the DC/OS Stateful Services SDK provides a simple,
declarative
API built on top of Mesos resource offers. You define your service
declaratively and the SDK manages installing and supervising the
service using resource offers from Mesos.</p>

<p>You can think of this as doing for stateful services what Marathon
does for stateless services, while still allowing you to drop down to
lower layers when you need more flexibility.</p>

<h2 id="multi-tier-service-support">Multi-tier service support</h2>
<p>Many stateful services have multiple interdependent tiers,
each running different processes.  For example, Apache HDFS is
composed of NameNodes, JournalNodes, and DataNodes. JournalNodes start
before NameNodes, which start before DataNodes.  To support one-click
install for users, as well as safe recovery from failures, the
scheduler must be aware of these dependencies.</p>

<h2 id="deployment-strategies">Deployment strategies</h2>
<p>Many stateful services have strict deployment requirements.  Some,
including, for instance Apache Cassandra, require nodes to be added to
the cluster one at at time.  Others may permit parallel deployment.
The DC/OS Stateful Services SDK includes deployment strategies
that support these different requirements.</p>

<h2 id="configuration-management">Configuration management</h2>

<p>For any framework, at least two components must be configured: the
scheduler and the service.  Scheduler configuration includes things
like node count, deployment strategies, and security parameters.
Service configuration includes resource settings such memory, CPU, and
ports, as well as any configuration passed on to the underlying
service.</p>

<p>The DC/OS Stateful Services SDK includes logic for reading
configuration from an external source (default: environment
variables), detecting changes to the configuration, and redeploying
any affected tasks.  It also supports marking certain configuration
parameters as “unmodifiable,” so that the user can’t change them after
install time.  For example, the disk size of permanent volumes cannot
be modified because volume size is static.</p>

<h2 id="interactive-upgrade-support">Interactive upgrade support</h2>
<p>Tasks must often be updated one at a time, and often depend on certain
administrative tasks like backup/restore.  You can choose to pause,
continue, or abort an upgrade interactively.</p>

<h2 id="fault-tolerance">Fault tolerance</h2>
<p>There are two component failures that any scheduler must defend
against: the scheduler and the service. The SDK sets up fault
tolerance for your scheduler automatically.</p>

<p>The SDK abstracts away task reconciliation with the Mesos master in
the case of task failure. In the case of service failure, the SDK
configures your scheduler to restart the task on the same node or, if
the node has failed, restarts the task on a different node. The
scheduler’s persistent volume is reused on restart. A new persistent
volume is created when a node fails.</p>

<p>The mechanism to determine whether a task has permanently failed is time-based by default.
When a task stays in a terminal state for some
configurable duration, it is determined to have failed. The default
duration is 20 minutes.  Once tasks have been determined to have
permanently failed, a second configurable parameter determines how many 
destructive task replacements may occur in a given time period.  By 
default, no more than one task may be destructively replaced in any 10 
minute period.  Finally, automatic destructive recovery may be entirely
suppressed.</p>

<p>Consider the simplest construct for the <code class="highlighter-rouge">DefaultScheduler</code>, in which
automatic destructive recovery configuration is exposed:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">DefaultScheduler</span> <span class="nf">create</span><span class="o">(</span>
        <span class="n">String</span> <span class="n">frameworkName</span><span class="o">,</span>
        <span class="n">PlanManager</span> <span class="n">deploymentPlanManager</span><span class="o">,</span>
        <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">permanentFailureTimeoutSec</span><span class="o">,</span>
        <span class="n">Integer</span> <span class="n">destructiveRecoveryDelaySec</span><span class="o">)</span> <span class="o">{</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">permanentFailureTimeoutSec</code> argument determines how long a task
must be in a terminal state before it is considered permanently failed.
If no value is present, automatic destructive recovery is turned off.</p>

<p>The <code class="highlighter-rouge">destructiveRecoveryDelaySec</code> argument determines how much time must
pass between destructive task replacement events.</p>

<p>The parameters above are one implementation of a more general
permanent task recovery scheme.  The task recovery scheme has two major components: a <em>safety
constraint</em> and a <em>performance constraint</em>.  In the example above, the
duration that must be waited until a task is considered permanently 
failed is the <em>safety constraint</em>. You can write a safety constraint that is more complex than a simple timeout.</p>

<p>In the example above, the recovery delay
parameter is the <em>performance constraint</em>.  Even if a large number of tasks could be safely
destructively replaced, it could cause performance degradation
as network traffic increases to reconstruct lost task state. In addition, you must be cautious when automating destructive recovery operations, so it is prudent to throttle the maximum rate of
destruction.</p>

<p>Recovery, like deployment, is mediated by a plan. Use the endpoint below to view the status of the plan.</p>
<div class="language-bash highlighter-rouge"><pre class="highlight"><code>GET /v1/plans/recovery
</code></pre>
</div>

<p>If no failures of any kind have occurred, you will see output similar to the snippet below.</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="err">phases:</span><span class="w"> </span><span class="err">[{</span><span class="w">
		</span><span class="err">id:</span><span class="w"> </span><span class="nt">"128d7df9-8605-4e1a-b98b-478821b1aeda"</span><span class="err">,</span><span class="w">
		</span><span class="err">name</span><span class="p">:</span><span class="w"> </span><span class="s2">"recovery"</span><span class="p">,</span><span class="w">
		</span><span class="err">steps</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
		</span><span class="err">status</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
	</span><span class="p">}</span><span class="err">],</span><span class="w">
	</span><span class="err">errors:</span><span class="w"> </span><span class="p">[]</span><span class="err">,</span><span class="w">
	</span><span class="err">status:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<p>If a task has crashed and been recovered, you will see a plan similar
to:</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="err">phases:</span><span class="w"> </span><span class="err">[{</span><span class="w">
		</span><span class="err">id:</span><span class="w"> </span><span class="nt">"88d944d3-4fc2-4605-889f-96b5429fb8af"</span><span class="err">,</span><span class="w">
		</span><span class="err">name</span><span class="p">:</span><span class="w"> </span><span class="s2">"recovery"</span><span class="p">,</span><span class="w">
		</span><span class="err">steps</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
			</span><span class="err">id:</span><span class="w"> </span><span class="nt">"ed4d2209-ab19-4242-b7da-d10cdf9e443b"</span><span class="err">,</span><span class="w">
			</span><span class="err">status</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="p">,</span><span class="w">
			</span><span class="err">name</span><span class="p">:</span><span class="w"> </span><span class="s2">"data-2"</span><span class="p">,</span><span class="w">
			</span><span class="err">message</span><span class="p">:</span><span class="w"> </span><span class="s2">"org.apache.mesos.scheduler.recovery.DefaultRecoveryBlock: 'data-2 [ed4d2209-ab19-4242-b7da-d10cdf9e443b]' has status: 'COMPLETE'. RecoveryType: TRANSIENT"</span><span class="w">
		</span><span class="p">}],</span><span class="w">
		</span><span class="err">status</span><span class="p">:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
	</span><span class="p">}</span><span class="err">],</span><span class="w">
	</span><span class="err">errors:</span><span class="w"> </span><span class="p">[]</span><span class="err">,</span><span class="w">
	</span><span class="err">status:</span><span class="w"> </span><span class="s2">"COMPLETE"</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<p>Note in particular the message that contains
<code class="highlighter-rouge">RecoveryType: TRANSIENT</code> for the step named <code class="highlighter-rouge">data-2</code>.  This message indicates a
recovery from a temporary failure.  The task was able to be successfully
recovered in its previous location with all its old resources, including
persistent volumes.  In the case of a permanent failure recovery, the
message would instead contain <code class="highlighter-rouge">RecoveryType: PERMANENT</code>.</p>

<h2 id="persistent-volumes">Persistent volumes</h2>
<p>Schedulers must create persistent volumes that will
live beyond the life a single task to tolerate failure, and they must
reserve these volumes to prevent other frameworks from taking them.
The SDK configures persistent volumes for your scheduler automatically.</p>

</div>
</div>
</body>

</html>
