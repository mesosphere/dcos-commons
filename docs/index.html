<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Dcos-commons by mesosphere</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Dcos-commons</h1>
        <p>The DC/OS Stateful Service SDK</p>
        <p class="view"><a href="api/index.html">Javadocs</a></p>
        <p class="view"><a href="swagger-api/index.html">API Reference</a></p>
        <p class="view"><a href="https://github.com/mesosphere/dcos-commons">View the Project on GitHub <small>mesosphere/dcos-commons</small></a></p>


        <ul>
          <li><a href="https://github.com/mesosphere/dcos-commons/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mesosphere/dcos-commons/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mesosphere/dcos-commons">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h1>

<p>Mesos is a powerful resource allocator, but writing a production
stateful service can be complex, tedious, and error-prone.  The DC/OS
Stateful Service SDK provides a high-level interface for
writing stateful services.  Now, you can write a stateful service
complete with
persistent volumes, fault tolerance, and configuration management in
about 100 lines of code.  This SDK is the product of Mesosphere's
experience writing production stateful services such as <a href="https://docs.mesosphere.com/latest/usage/service-guides/kafka/">DC/OS Apache
Kafka</a>
, <a href="https://docs.mesosphere.com/latest/usage/service-guides/%0Acassandra/">DC/OS Apache
Cassandra</a>, and <a href="https://docs.mesosphere.com/latest/usage/service-guides/hdfs/">DC/OS Apache
HDFS</a>.</p>

<p>Read about the <a href="#Features-at-a-glance">features</a> to learn more about
the DC/OS Stateful Service SDK.</p>

<h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1>

<p>In this tutorial, we'll build an example
service called <code>data-store</code>.  It is composed of a small number of
<code>meta-data</code> nodes and a larger number of <code>data</code> nodes.  This structure
is meant to model a service with a small number of coordinating master
nodes and a large number of dependent agent nodes.  Each task runs a
command that writes some data to a file, then sleeps.</p>

<p>The goal state for this fictional <code>data-store</code> is to keep two
<code>meta-data</code> and N <code>data</code> nodes running, where, initially, N = 3.
<code>meta-data</code> nodes must come up before <code>data</code> nodes.  The service
scales by starting more <code>data</code> nodes.</p>

<p>This tutorial includes code snippets. The final
source code is available at
<a href="http://github.%0Acom/mesosphere/sdk-reference-framework">http://github.com/mesosphere/sdk-reference-framework</a>.</p>

<h2>
<a id="architecture" class="anchor" href="#architecture" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Architecture</h2>

<p><img src="./architecture.png" alt="DC/OS Service Architecture"></p>

<p>A DC/OS service is composed of <strong>schedulers</strong> and <strong>executors</strong>.  The
scheduler is run by Marathon, which supervises the scheduler,
restarting it upon failure.  The scheduler, in turn, starts and
supervises the executors.  If specified in the <code>ServiceSpecification</code>,
the
executors will contain a <strong>persistent volume</strong>, which is a folder or
mount point on the agent that persists even after a task fails. This
allows a stateful service to recover with its data intactafter task
failure or temporary node failure.</p>

<p>In this tutorial, <code>data-store</code> is the scheduler, and <code>meta-data-{0,1}</code>
and <code>data-{0-1}</code> are the executors.</p>

<h2>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Requirements</h2>

<ul>
<li>JDK 8</li>
<li>Gradle 3.1 (recommended)</li>
<li>AWS account with S3 upload permissions</li>
<li><a href="https://aws.amazon.com/cli/"><code>aws</code> CLI</a></li>
</ul>

<h1>
<a id="create-a-project" class="anchor" href="#create-a-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create a Project</h1>

<p>The Java library for The DC/OS Stateful Services SDK is
<code>dcos-commons</code>.  Java projects using <code>dcos-commons</code> can use any Java
build system, but for this tutorial, we'll assume you're using Gradle.</p>

<p>First, we create our <code>build.gradle</code> file:</p>

<pre><code>group 'com.mesosphere.sdk'
version '1.0-SNAPSHOT'

apply plugin: 'java'
apply plugin: 'application'

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url "http://downloads.mesosphere.com/maven/"
    }
}

dependencies {
    compile "mesosphere:dcos-commons:0.7.10-SNAPSHOT"
    compile "org.slf4j:slf4j-simple:1.7.21"
}

task wrapper(type: Wrapper) {
    gradleVersion = '3.1'
}

mainClassName = 'com.mesosphere.sdk.reference.scheduler.Main'
</code></pre>

<h1>
<a id="define-a-service" class="anchor" href="#define-a-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Define a Service</h1>

<h2>
<a id="create-a-service-specification" class="anchor" href="#create-a-service-specification" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Create a Service Specification</h2>

<p>The first step to running a service is to create a
<code>ServiceSpecification</code>, which defines the behavior of the service.</p>

<p>A <code>ServiceSpecification</code> is mostly a list of <code>TaskSet</code>s.
The tasks defined in this list are launched in order.  We can use this
ordering to define tiers of services.  In this example, we want all
<code>meta-data</code> nodes to come up before any <code>data</code> node:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_METADATA_NAME</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>meta-data<span class="pl-pds">"</span></span>;
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">int</span> <span class="pl-c1">TASK_METADATA_COUNT</span> <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>METADATA_COUNT<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_METADATA_CPU</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>METADATA_CPU<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_METADATA_MEM_MB</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>METADATA_MEM<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_METADATA_DISK_MB</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>METADATA_DISK<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_METADATA_URI</span> <span class="pl-k">=</span> <span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>METADATA_URI<span class="pl-pds">"</span></span>);
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_METADATA_CMD</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bash meta-data<span class="pl-pds">"</span></span>;

<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_DATA_NAME</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>;
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">int</span> <span class="pl-c1">TASK_DATA_COUNT</span> <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>DATA_COUNT<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_DATA_CPU</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>DATA_CPU<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_DATA_MEM_MB</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>DATA_MEM<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">double</span> <span class="pl-c1">TASK_DATA_DISK_MB</span> <span class="pl-k">=</span> <span class="pl-smi">Double</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>DATA_DISK<span class="pl-pds">"</span></span>));
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_DATA_URI</span> <span class="pl-k">=</span> <span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>DATA_URI<span class="pl-pds">"</span></span>);
<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-c1">TASK_DATA_CMD</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bash data<span class="pl-pds">"</span></span>;

<span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">ServiceSpecification</span> getServiceSpecification() {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">ServiceSpecification</span>() {
        <span class="pl-k">@Override</span>
        <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
            <span class="pl-k">return</span> <span class="pl-c1">SERVICE_NAME</span>;
        }

        <span class="pl-k">@Override</span>
        <span class="pl-k">public</span> <span class="pl-k">List&lt;<span class="pl-smi">TaskSet</span>&gt;</span> <span class="pl-en">getTaskSets</span>() {
            <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(
                    <span class="pl-smi">DefaultTaskSet</span><span class="pl-k">.</span>create(
                            <span class="pl-c1">TASK_METADATA_COUNT</span>,
                            <span class="pl-c1">TASK_METADATA_NAME</span>,
                            getCommand(<span class="pl-c1">TASK_METADATA_CMD</span>, <span class="pl-c1">TASK_METADATA_URI</span>),
                            getResources(<span class="pl-c1">TASK_METADATA_CPU</span>, <span class="pl-c1">TASK_METADATA_MEM_MB</span>),
                            getVolumes(<span class="pl-c1">TASK_METADATA_DISK_MB</span>, <span class="pl-c1">TASK_METADATA_NAME</span>),
                            <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(<span class="pl-smi">TaskTypeGenerator</span><span class="pl-k">.</span>createAvoid(<span class="pl-c1">TASK_METADATA_NAME</span>)),
                            <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(getHealthCheck(<span class="pl-c1">TASK_METADATA_NAME</span>))),
                    <span class="pl-smi">DefaultTaskSet</span><span class="pl-k">.</span>create(
                            <span class="pl-c1">TASK_DATA_COUNT</span>,
                            <span class="pl-c1">TASK_DATA_NAME</span>,
                            getCommand(<span class="pl-c1">TASK_DATA_CMD</span>, <span class="pl-c1">TASK_DATA_URI</span>),
                            getResources(<span class="pl-c1">TASK_DATA_CPU</span>, <span class="pl-c1">TASK_DATA_MEM_MB</span>),
                            getVolumes(<span class="pl-c1">TASK_DATA_DISK_MB</span>, <span class="pl-c1">TASK_DATA_NAME</span>),
                            <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(<span class="pl-smi">TaskTypeGenerator</span><span class="pl-k">.</span>createAvoid(<span class="pl-c1">TASK_DATA_NAME</span>)),
                            <span class="pl-smi">Optional</span><span class="pl-k">.</span>of(getHealthCheck(<span class="pl-c1">TASK_DATA_NAME</span>))));
        }
    };
}</pre></div>

<p>A <code>TaskSet</code> contains the bulk of the definition.  It
contains the command to run, the resources to run with, and the number
of tasks.  As you can see, it is common for DC/OS services to read
their config from environment variables.</p>

<p>At a minimum, the command must contain a <code>value</code>, which is the shell
command to invoke.  It will likely also contain one or more <code>URIs</code>
pointing to resources to download before execution.  In this example,
we're downloading the <code>metadata</code> and <code>data</code> binaries from an HTTP
server:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">CommandInfo</span> getCommand(<span class="pl-smi">String</span> cmd, <span class="pl-smi">String</span> uri) {
    <span class="pl-k">return</span> <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">CommandInfo</span><span class="pl-k">.</span>newBuilder()
              .addUris(<span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">CommandInfo</span><span class="pl-c1"><span class="pl-k">.</span>URI</span><span class="pl-k">.</span>newBuilder()<span class="pl-k">.</span>setValue(uri))
              .setValue(cmd)
              .build();
}</pre></div>

<p>Resurces are specified via <code>ResourceSpecification</code>s.  Tasks must run
with at least <code>cpus</code> and <code>mem</code> resources, though we may specify any
Mesos resource, including <code>ports</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">Collection&lt;<span class="pl-smi">ResourceSpecification</span>&gt;</span> getResources(<span class="pl-k">double</span> cpu, <span class="pl-k">double</span> memMb) {
    <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(
            <span class="pl-k">new</span> <span class="pl-smi">DefaultResourceSpecification</span>(
                    <span class="pl-s"><span class="pl-pds">"</span>cpus<span class="pl-pds">"</span></span>,
                    <span class="pl-smi">ValueUtils</span><span class="pl-k">.</span>getValue(<span class="pl-smi">ResourceUtils</span><span class="pl-k">.</span>getUnreservedScalar(<span class="pl-s"><span class="pl-pds">"</span>cpus<span class="pl-pds">"</span></span>, cpu)),
                    <span class="pl-c1">ROLE</span>,
                    <span class="pl-c1">PRINCIPAL</span>),
            <span class="pl-k">new</span> <span class="pl-smi">DefaultResourceSpecification</span>(
                    <span class="pl-s"><span class="pl-pds">"</span>mem<span class="pl-pds">"</span></span>,
                    <span class="pl-smi">ValueUtils</span><span class="pl-k">.</span>getValue(<span class="pl-smi">ResourceUtils</span><span class="pl-k">.</span>getUnreservedScalar(<span class="pl-s"><span class="pl-pds">"</span>mem<span class="pl-pds">"</span></span>, memMb)),
                    <span class="pl-c1">ROLE</span>,
                    <span class="pl-c1">PRINCIPAL</span>));
}</pre></div>

<p>In Mesos, <code>disk</code> is just another resource, like <code>cpus</code> and <code>mem</code>.
However, stateful services must manage <code>disk</code> differently.  Rather
than simply accepting the resource like <code>cpus</code> or <code>mem</code>, the scheduler
must first create a
<a href="http://mesos.apache.org/documentation/latest/persistent-%0Avolume/">volume</a>
from the disk resources so that it persists beyond the lifetime of the
task.  The <code>VolumeSpecification</code> is a high-level interface that
handles this for us:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">Collection&lt;<span class="pl-smi">VolumeSpecification</span>&gt;</span> getVolumes(<span class="pl-k">double</span> diskMb, <span class="pl-smi">String</span> taskName) {
    <span class="pl-smi">VolumeSpecification</span> volumeSpecification <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DefaultVolumeSpecification</span>(
            diskMb,
            <span class="pl-smi">VolumeSpecification</span><span class="pl-k">.</span><span class="pl-smi">Type</span><span class="pl-c1"><span class="pl-k">.</span>ROOT</span>,
            taskName <span class="pl-k">+</span> <span class="pl-c1">CONTAINER_PATH_SUFFIX</span>,
            <span class="pl-c1">ROLE</span>,
            <span class="pl-c1">PRINCIPAL</span>);

    <span class="pl-k">return</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(volumeSpecification);
}</pre></div>

<p>Finally, we can attach a health check to our tasks.  If the check
fails, the Mesos agent will kill the task, and the scheduler will
restart it.</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">HealthCheck</span> getHealthCheck(<span class="pl-smi">String</span> name) {
    <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">CommandInfo</span> commandInfo <span class="pl-k">=</span> <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">CommandInfo</span><span class="pl-k">.</span>newBuilder()
        .setValue(<span class="pl-s"><span class="pl-pds">"</span>stat %s%s/output<span class="pl-pds">"</span></span><span class="pl-k">.</span>format(name, <span class="pl-c1">CONTAINER_PATH_SUFFIX</span>))
        .build()

    <span class="pl-k">return</span> <span class="pl-smi">Protos</span><span class="pl-k">.</span><span class="pl-smi">HealthCheck</span><span class="pl-k">.</span>newBuilder()
        .setCommand(commandInfo)
        .build();
}</pre></div>

<h2>
<a id="define-a-main-class" class="anchor" href="#define-a-main-class" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Define a Main Class</h2>

<p>Now that we have a <code>ServiceSpecification</code>, we must define a Main class
that runs it.  To do this, create a <code>Service</code> object, and register the
<code>ServiceSpecification</code> with it:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Main</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-k">int</span> <span class="pl-c1">API_PORT</span> <span class="pl-k">=</span> <span class="pl-smi">Integer</span><span class="pl-k">.</span>valueOf(<span class="pl-smi">System</span><span class="pl-k">.</span>getenv(<span class="pl-s"><span class="pl-pds">"</span>PORT0<span class="pl-pds">"</span></span>));
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) <span class="pl-k">throws</span> <span class="pl-smi">Exception</span> {
        <span class="pl-k">new</span> <span class="pl-smi">DefaultService</span>(<span class="pl-c1">API_PORT</span>)<span class="pl-k">.</span>register(getServiceSpecification());
    }
}</pre></div>

<p><code>DefaultService</code> takes a single parameter, <code>apiPort</code>. <code>apiPort</code>
specifies which
port its HTTP server will bind to.  Upon registering the
<code>ServiceSpecification</code>, our service will start its HTTP server,
register as a Mesos framework, and start launching tasks.</p>

<h1>
<a id="deployment" class="anchor" href="#deployment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deployment</h1>

<p>Now that we've defined our service, let's build and install it.  The
first thing we'll need is a DC/OS cluster.</p>

<h2>
<a id="start-cluster" class="anchor" href="#start-cluster" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Start cluster</h2>

<p>Go to <a href="https://dcos.io/install/">https://dcos.io/install/</a> to install
a DC/OS cluster.</p>

<h2>
<a id="install-the-dcos-cli" class="anchor" href="#install-the-dcos-cli" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Install the DC/OS CLI</h2>

<p>If you have not already installed the CLI, do so by following <a href="https://dcos.io/docs/latest/usage/cli/install/">these
instructions</a>.</p>

<h2>
<a id="install" class="anchor" href="#install" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Install</h2>

<p>Now that we have our cluster and CLI, we can install our service.
DC/OS services are deployed to users via DC/OS packages.  The first
step is to define our package.</p>

<h3>
<a id="define-a-dcos-package" class="anchor" href="#define-a-dcos-package" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Define a DC/OS Package</h3>

<p>A DC/OS package is a set of four
files.  You can learn more about the package format
<a href="http://github.com/mesosphere/universe">here</a>, but, in summary, it
looks like this:</p>

<ul>
<li>
<strong>package.json</strong>: Package metadata</li>
<li>
<strong>marathon.json.mustache</strong>: Marathon app definition.  The template
is rendered with the values in config.json, resource.json,
and user-provided config.</li>
<li>
<strong>config.json</strong>: JSON Schema defining the configuration for the app.</li>
<li>
<strong>resource.json</strong>: External resources.</li>
</ul>

<p>The majority of the package definition resides in
<strong>marathon.json.mustache</strong>.  See the
<a href="https://github.com/mesosphere/sdk-reference-framework/tree/%0Amaster/universe">reference
framework</a>
for an example.</p>

<p>Let's place these files in a directory in our project called
<code>universe/</code>.</p>

<p>Now we build our project:</p>

<div class="highlight highlight-source-shell"><pre>$ ./gradlew distZip</pre></div>

<h3>
<a id="build-a-dcos-package" class="anchor" href="#build-a-dcos-package" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Build a DC/OS Package</h3>

<p>Then we must build our DC/OS package.  DC/OS packages are stored in
<em>repos</em>.  The most common repo is the
<a href="https://github.com/mesosphere/universe"><em>Mesosphere Universe</em></a>, which
is public. We would publish our package there if we wished to
share it with the world.  For now, we just want to create a simple
repo containing our single package.</p>

<p><strong>NOTE:</strong> The current workflow of creating a package <em>and</em> a repo is
  cumbersome.  We're sorry about this.  DC/OS 1.10, which is slated to
  be released in December 2016, will introduce the ability to install
  a package directly, rather than forcing you to wrap it in a repo.</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">~</span> $ <span class="pl-c1">cd</span> /path/to/dcos-commons
dcos-commons $ ./tools/ci_upload.py \
      data-store \
      universe/ \
      reference-scheduler/build/distributions/scheduler.zip</pre></div>

<p><code>./ci_upload.py</code> uploads the artifact to S3, rewrites the package to
include links to the artifact, creates a repo containing that package,
and uploads that repo to S3.  The end result is a URL for a DC/OS
repo.</p>

<p>We now add this repo to our cluster:</p>

<div class="highlight highlight-source-shell"><pre>$ dcos package repo add --index=0 dev-repo <span class="pl-k">&lt;</span>repo_url<span class="pl-k">&gt;</span></pre></div>

<p>Then, install our package:</p>

<div class="highlight highlight-source-shell"><pre>$ dcos package install data-store</pre></div>

<p>Visit <strong>Services</strong> &gt; <strong>data-store</strong> in the DC/OS UI to watch
<code>data-store</code> deploying.</p>

<p>To verify that <code>data-store</code> has completed deploying, make the
following HTTP request from the DC/OS CLI. To learn how to make
requests to the HTTP API,
please read the <a href="#http-api">HTTP API</a> section:</p>

<pre><code>GET /v1/plan/status
</code></pre>

<p>This HTTP request will return JSON to indicate the status of the
service. If the deployment is complete, <code>plan.status</code> will equal
"COMPLETE".</p>

<p>When deployment is complete, two <code>meta-data</code>
tasks and three <code>data</code> tasks will be visible in the DC/OS Services UI.</p>

<h2>
<a id="uninstall" class="anchor" href="#uninstall" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Uninstall</h2>

<p>To do a complete uninstall, we first uninstall our service using the
DC/OS CLI.  This stops and tears down the framework.</p>

<div class="highlight highlight-source-shell"><pre>$ dcos package uninstall data-store</pre></div>

<p>However, uninstalling the package does not remove persistent state
like Zookeeper state and persistent volumes. Mesosphere provides a
Docker image to remove persistent state:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">local</span> $ AUTH_TOKEN=<span class="pl-s"><span class="pl-pds">$(</span>dcos config show core.dcos_acs_token<span class="pl-pds">)</span></span>
<span class="pl-k">local</span> $ dcos node ssh --master-proxy --leader
cluster $ docker run mesosphere/janitor /janitor.py \
    -r data-store-role \
    -p data-store-principal \
    -z dcos-service-data-store \
    --auth_token=<span class="pl-smi">$AUTH_TOKEN</span></pre></div>

<p>For more information on the janitor image, see
<a href="https://github.com/mesosphere/framework-cleaner">https://github.com/mesosphere/framework-cleaner</a>.</p>

<h1>
<a id="plan-management" class="anchor" href="#plan-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Plan management</h1>

<p>As noted earlier, stateful services often have particular deployment
requirements.  These deployments may involve the initial creation of
Tasks or a change in Task configuration or the scaling of a
particular kind of task or an upgrade to a new version of a Task.  Each
of these scenarios comes with attendant risks and benefits.  In some
cases (as in initial install) you may be happy to have a service rollout
without intervention.  In others, as in a configuration update, one may
wish to deploy some portion of a service and check stability before
completing a deployment.</p>

<p>In order to provide the necessary flexibility and control necessary to
achieve these outcomes, the SDK organizes deployment of tasks by means
of Plans. Plans are composed of Phases which are composed of Blocks.
A Block encapsulates the smallest element of work executed in a Plan and
is the plan element which encapsulates the launching of Mesos Tasks.</p>

<p>Phases are groups of Blocks which have some semantic relationship.  At
least two plans are generated automatically by the SDK when presented
with a <code>ServiceSpecification</code>.  These are the deployment and recovery
plans.  The deployment plan is concerned with deploying Tasks.  It
deploys Tasks for the first time, and when configuration updates are
indicated by a user.  The recovery plan is concerned with defining the
necessary operations which must be performed when transient or permanent
failures are encountered.</p>

<p>Let us examine the deployment plan of the example data-store service
after its initial installation has completed.</p>

<p>Executing the following command:</p>

<pre><code>GET /v1/plan"
</code></pre>

<p>generates the following output:</p>

<div class="highlight highlight-source-json"><pre>{
    <span class="pl-s"><span class="pl-pds">"</span>phases<span class="pl-pds">"</span></span>: [{
        <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>31a3ca99-bdbd-45dd-a8f0-cc93feade61e<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>meta-data<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>blocks<span class="pl-pds">"</span></span>: [{
            <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>2a0db529-095b-4b63-8c56-075aa442c898<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>meta-data-0<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Block: meta-data-0<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>has_decision_point<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>
        }, {
            <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>99210582-cdfb-4b63-95e9-19600f117dc7<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>meta-data-1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Block: meta-data-1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>has_decision_point<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>
        }],
        <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
    }, {
        <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>927ac279-b969-4106-9089-40264ae15dc4<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>blocks<span class="pl-pds">"</span></span>: [{
            <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>efcf9dc0-488f-4f9e-ae0c-1ac16c401e0a<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>data-0<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Block: data-0<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>has_decision_point<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>
        }, {
            <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>a0e0905b-d4da-4cec-84b9-461a60a92818<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>data-1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Block: data-1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>has_decision_point<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>
        }, {
            <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>fa85a843-e6eb-4074-b353-875197a18adb<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>data-2<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>Block: data-2<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>has_decision_point<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>
        }],
        <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
    }],
    <span class="pl-s"><span class="pl-pds">"</span>errors<span class="pl-pds">"</span></span>: [],
    <span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
}</pre></div>

<p>The first thing to notice is that the <code>TaskSet</code>s defined in a
<code>ServiceSpecification</code> are mapped to deployment Phases. The data-store
example service has <code>TaskSet</code>s encapsulating <code>meta-data</code> and <code>data</code>
Tasks in that order.  The deployment plan above has the respective
<code>meta-data</code> and <code>data</code> Phases.</p>

<p>In its default configuration, the two <code>data</code> Tasks and three <code>meta-data</code>
Tasks are launched.  We can see that a Block has been created
encapsulating each of those tasks.  The names of Blocks map to the names
of the <code>TaskSpecification</code> objects within a <code>TaskSet</code>.  The status of a
Block can be in one of 3 states.  It may be <code>PENDING</code>, <code>IN_PROGRESS</code>, or
<code>COMPLETE</code>.</p>

<p>By default all Phases and the Blocks within them are rolled out
serially.  Each Block must reach a <code>COMPLETE</code> state before the
next Block may be started.  Beyond this automatic behavior, it is often
desirable to manually pause/resume a deployment.  For example, in a
production setting multiple uncoordinated deployments may cause
unexpected effects, including causing unavailability or severely
degraded performance.  In thes cases and others, the ability to pause
individual deployments while others continue without performing a full
rollback can be helpful.</p>

<p>The <code>has_decision_point</code> fields above indicate whether a user has indicated
a desire to pause a deployment at a particular Block.</p>

<p>A Plan's execution may be paused or continued by POST commands executed
against the HTTP endpoints at the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L53"><code>/v1/plan/interrupt</code></a>
and <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L46"><code>/v1/plan/continue</code></a>
respectively.  For example:</p>

<pre><code>POST /v1/plan/interrupt"
</code></pre>

<pre><code>POST /v1/plan/continue"
</code></pre>

<p>Finally, beyond manual control of Plan execution behavior it may be
desirable in certain failure scenarios to either restart the execution
of a Block or force its completion.  Restarting a Block in default
implementations simply sets a Block's status to <code>PENDING</code> and allows the
normal Block processing system to do the necessary work to drive a Block
to completion.  This can be accomplished by issuing a POST command to
the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L69"><code>/v1/plan/restart</code></a>
endpoint.  For example to restart the Block associated with the first
data task <code>data-0</code> one would issue the following command:</p>

<div class="highlight highlight-source-shell"><pre>POST /v1/plan/restart<span class="pl-k">?</span>phase=927ac279-b969-4106-9089-40264ae15dc4<span class="pl-k">&amp;</span>block=efcf9dc0-488f-4f9e-ae0c-1ac16c401e0a<span class="pl-s"><span class="pl-pds">"</span></span></pre></div>

<p>Forcing the completion of a block can be accomplished in a similar
manner by issuing a POST command against the <a href="https://github.com/mesosphere/dcos-commons/blob/master/src/main/java/org/apache/mesos/scheduler/plan/api/PlanResource.java#L69"><code>/v1/plan/forceComplete</code></a>
endpoint. For example to force the completion of the second <code>meta-data</code>
block one would issue the following command:</p>

<div class="highlight highlight-source-shell"><pre>POST /v1/plan/forceComplete<span class="pl-k">?</span>phase=31a3ca99-bdbd-45dd-a8f0-cc93feade61<span class="pl-k">&amp;</span>block=99210582-cdfb-4b63-95e9-19600f117dc7<span class="pl-s"><span class="pl-pds">"</span></span></pre></div>

<h1>
<a id="update-configuration" class="anchor" href="#update-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Update configuration</h1>

<p>We saw in the <a href="#create-a-service-specification">Service Specification
section</a> that the service's
configuration is read in through environment variables.  You can use
any source of configuration, but DC/OS Services are typically
configured through environment variables.  To make a configuration
change, modify the corresponding environment variable,
then restart the scheduler.  When the scheduler comes back up, it will
read its new configuration and transition to the new state.</p>

<p>For example, in order to scale the <code>data-store</code> service from 3 <code>data</code>
nodes to 5, modify the <code>DATA_COUNT</code> environment variable. To modify
it:</p>

<p>1) Go the the <strong>Services</strong> &gt; <strong>data-store</strong> page of the DC/OS UI.</p>

<p>1) Click <strong>Edit</strong>.</p>

<p>1) Click the <strong>Environment Variables</strong> tab.</p>

<p>1) Change the value of <code>DATA_COUNT</code> from 3 to 5.</p>

<p>1) Click <strong>Deploy Changes</strong>.</p>

<p>This will restart the scheduler with the updated environment.  When
the scheduler starts up, it detects that it is already running 3
<code>data</code> tasks and starts 2 more in order to reach the goal state of 5.
We should observe two more tasks starting, <code>data-3</code> and <code>data-4</code>.</p>

<h2>
<a id="task-configuration-management" class="anchor" href="#task-configuration-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Task Configuration management</h2>

<p>While the above describes configuration of the scheduler itself via
environment variables, there's also a need for configuration of the
underlying service tasks themselves in a flexible way.</p>

<p>To simplify the common task of getting user-facing configuration to
service tasks, the developer may follow the following convention in
naming the environment variables for these configuration options:
<code>TASKCFG_&lt;TASK_TYPE&gt;_&lt;CFGNAME&gt;</code>, where <code>&lt;TASK_TYPE&gt;</code> has been
converted from the task type to fit the requirements of environment
variables:</p>

<ul>
<li>Uppercased</li>
<li>Non-alphanumeric characters (punctuation, whitespace) converted
to underscores</li>
</ul>

<p>For example, an option named <code>FOO</code> for tasks of type <code>index.mgr</code>
should be named <code>TASKCFG_INDEX_MGR_FOO</code>, while an option <code>BAR</code> for
tasks of type <code>data-node</code> should be named <code>TASKCFG_DATA_NODE_BAR</code>.
These configuration options will automatically be forwarded to the
environments of the matching tasks as environment variables, with
the <code>TASKCFG_&lt;TASK_TYPE&gt;_</code> prefixes removed. A special prefix of
<code>TASKCFG_ALL_&lt;NAME&gt;</code> may be used for any options that should be
passed to <em>every</em> task type.</p>

<p>A common need for service developers is an easy way to write
configuration files before launching tasks. To fulfill this need,
the developer may provide configuration file template(s) in their
TaskSet(s). These templates follow the <a href="https://mustache.github.io/">mustache</a>
templating format, similar to what's used in DC/OS packaging. The
templates will be automatically rendered against the task's
environment (which is customized as described above), and then
each written to relative file paths specified by the developer.</p>

<h1>
<a id="restart-tasks" class="anchor" href="#restart-tasks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Restart tasks</h1>

<p>When a task fails, the scheduler will attempt to restart the on the
same node, using the same persistent volume as the previous task.</p>

<p>There are two cases where you must manually restart tasks:</p>

<p>1) If an agent permanently fails or is ailing, the scheduler will
never receive an
offer with the expected persistent volume, and will thus never
automatically restart the task.  We must restart it manually on a
different node.  This is called <em>replacing</em> the task.</p>

<p>2) If a task is stuck or performing poorly, or we just want to restart
it for debugging, we may need to restart the task manually on the same
node.</p>

<p>You can perform both actions using the same endpoint:</p>

<pre><code>POST /v1/tasks/restart/&lt;task-name&gt;?replace={true|false}
</code></pre>

<p>If <code>replace=true</code>, this action will replace the task on a separate
node.  If <code>replace=false</code>, it will restart the task on the same node.</p>

<h1>
<a id="placement" class="anchor" href="#placement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Placement</h1>

<p>The <code>DefaultScheduler</code> makes no intelligent placement decisions.  It
will run a task on first offer it gets that satisfies the resource
constraints for that task.</p>

<p>Placement decisions may be customized using <em>Placement Constraints</em>,
which
are rules that specify how tasks should be placed in the cluster.
These rules
are enforced by filtering the resource offers returned by Mesos.
Resources that do not conform to the rules are removed from the list.</p>

<p>You can define placement constraints on a
per-task basis by customizing the return value of
<code>TaskSpecification.getPlacement()</code>:</p>

<pre><code>public Optional&lt;PlacementRuleGenerator&gt; getPlacement() {
    // avoid systems which are running an "index" task:
    return Optional.of(TaskTypeGenerator.createAvoid("index"));
}
</code></pre>

<p>You can use some of the common <code>PlacementRule</code>s
and/or <code>PlacementRuleGenerator</code> implementations provided in the
<a href="https://github.com/mesosphere/dcos-commons/tree/%0Amaster/src/main/java/org/apache/mesos/offer/constrain">offer.constrain</a>
package. You can also create your own <code>PlacementRule</code>s for custom
constraints. Custom constraints can take advantage of anything present
in the Mesos <code>Offers</code>
or in the other running <code>TaskInfo</code>s.</p>

<h1>
<a id="logs" class="anchor" href="#logs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Logs</h1>

<p>The <code>stdout</code> and <code>stderr</code> streams for all tasks running in Mesos,
including the scheduler and executors, are captured and written to
files in that task's sandbox. You can view these files from the
<strong>Services</strong> tab of the DC/OS UI or from the CLI. <a href="https://docs.mesosphere.com/1.8/administration/logging/service-%0Alogs/">Learn
more</a>.</p>

<p>All code in <code>dcos-commons</code>, including the <code>DefaultScheduler</code>, uses
<code>slf4j</code> to write logs to <code>stderr</code>.  To write your own logging code,
first create a <code>LOGGER</code>:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">Logger</span> <span class="pl-c1">LOGGER</span> <span class="pl-k">=</span> <span class="pl-smi">LoggerFactory</span><span class="pl-k">.</span>getLogger(<span class="pl-smi">Main</span><span class="pl-k">.</span>class);</pre></div>

<p>Then write to it:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-c1">LOGGER</span><span class="pl-k">.</span>info(<span class="pl-s"><span class="pl-pds">"</span>Starting reference scheduler with args: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(args));</pre></div>

<p>The contents of <code>stdout</code> and <code>stderr</code> for the executors is entirely
dependent on the command specified in our <code>ServiceSpecification</code>.</p>

<h1>
<a id="tests" class="anchor" href="#tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tests</h1>

<h2>
<a id="unit-tests" class="anchor" href="#unit-tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Unit Tests</h2>

<p><code>dcos-commons</code> contains unit
tests written with <code>junit</code> and <code>mockito</code>. You can also create your own
unit tests.</p>

<h2>
<a id="integration-tests" class="anchor" href="#integration-tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Integration Tests</h2>

<p>The <a href="https://github.com/dcos/shakedown">shakedown</a> library is a tool for
writing integration tests for DC/OS services.  For an example, see
<a href="https://github.com/mesosphere/dcos-kafka-service/tree/master/integration/tests">the tests for DC/OS
Kafka</a>.</p>

<h1>
<a id="metrics" class="anchor" href="#metrics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Metrics</h1>

<p>As of DC/OS 1.8, this section is only relevant to DC/OS Enterprise
Edition, but support has recently been
<a href="http://github.com/dcos/dcos-metrics">open-sourced</a>
and should soon be available in Open DC/OS. For more information,
see the <a href="http://github.com/dcos/dcos-metrics">dcos-metrics</a>
repository and stop by the #day2ops channel on <a href="https://chat.dcos.io">DC/OS
Slack</a>.</p>

<p>DC/OS Metrics automatically provides all Mesos containers with a
unique UDP endpoint for outputting <code>statsd</code>-formatted metrics. The
endpoint
is advertised via two container environment variables:
<code>STATSD_UDP_HOST</code>
and <code>STATSD_UDP_PORT</code>. Any metrics sent to this advertised endpoint
will automatically be tagged with the originating container and
forwarded upstream to the cluster's metrics infrastructure.</p>

<p>You can take advantage of this endpoint for your service
scheduler as well as for the underlying service tasks themselves. For
instance, you can configure your service's tasks to emit to the
locally-advertised endpoint as they are launched.</p>

<p><strong>Note:</strong> The environment-advertised endpoint is
unique to each container and cannot be reused across containers.</p>

<p>The data sent to this endpoint should follow the standard <code>statsd</code>
text format, optionally with multiple newline-separated values
per UDP packet.
<a href="Datadog-%0Aextension">http://docs.datadoghq.com/guides/dogstatsd/#datagram-format</a>
tags are also supported, so the application may also include its own
custom tags:</p>

<pre><code>memory.usage_mb:5|g
frontend.query.latency_ms:46|g|#shard_id:6,section:frontpage
</code></pre>

<p>See also:</p>

<ul>
<li><a href="https://github.com/dcos/dcos-metrics">dcos-metrics repo</a></li>
<li><a href="https://github.com/dcos/dcos-metrics/tree/master/examples/%0Astatsd-emitter">Sample StatsD emitter
process</a></li>
<li><a href="https://github.com/mesosphere/dcos-kafka-service/blob/%0A30acc60676ba9362ddb9b74f208b36d257a78f93/kafka-config-overrider/src/%0Amain/java/com/mesosphere/dcos/kafka/config/Overrider.java#L163">Metrics configuration for
Kafka</a></li>
<li><a href="https://github.com/mesosphere/dcos-cassandra-service/blob/%0A38360f9f78d7063824ad77f9871108fe5609e54d/cassandra-executor/src/main/%0Ajava/com/mesosphere/dcos/cassandra/executor/metrics/MetricsConfig.java%0A#L68">Metrics configuration for
Cassandra</a></li>
</ul>

<h1>
<a id="service-discovery" class="anchor" href="#service-discovery" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Service Discovery</h1>

<p>Mesos-DNS assigns every Mesos task a DNS address of the form
<code>&lt;task-name&gt;.&lt;framework-name&gt;.mesos</code>.  In our example (running 3 data
nodes), Mesos-DNS creates the following addresses:</p>

<pre><code>meta-data-0.data-store.mesos
meta-data-1.data-store.mesos
meta-data-2.data-store.mesos
data-0.data-store.mesos
data-1.data-store.mesos
</code></pre>

<p>It also creates a DNS entry for the scheduler:</p>

<pre><code>data-store.marathon.mesos
</code></pre>

<p>If the tasks listen on reserved port(s), clients will also need
these port(s) in order to establish a connection.  We can fetch these
port(s) along with the DNS entry for a task via the following
endpoint:</p>

<div class="highlight highlight-source-shell"><pre>GET /v1/tasks/connection/{task-name}</pre></div>

<p>This HTTP request returns:</p>

<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>dns<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>data-0.data-store.mesos<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>ports<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>4388<span class="pl-pds">"</span></span>
}</pre></div>

<p>If the task has multiple ports reserved, they will be displayed as a
comma-delimited sequence of ranges. e.g. <code>"8080,2000-3000"</code>.</p>

<h1>
<a id="secrets-management" class="anchor" href="#secrets-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Secrets Management</h1>

<p>This section is only relevant to DC/OS Enterprise Edition.</p>

<p>In a DC/OS Enterprise Edition cluster running in strict security mode,
all schedulers must authenticate with the Mesos master using DC/OS
service accounts.  For instructions on creating a service account,
read
[this][<a href="https://docs.mesosphere.com/1.8/administration/id-and-access-">https://docs.mesosphere.com/1.8/administration/id-and-access-</a>
mgt/service-auth/]</p>

<p>Mesos schedulers authenticate to the master by providing a <code>principal</code>
and <code>secret</code>.  In DC/OS, the <code>principal</code> must be the DC/OS Service
Account ID, and the <code>secret</code> must be the private key.  To start the
scheduler with access to the private key, we must integrate with
Marathon's DC/OS secret support:</p>

<div class="highlight highlight-source-js"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>env<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>DCOS_SERVICE_ACCOUNT_CREDENTIAL<span class="pl-pds">"</span></span><span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>serviceCredential<span class="pl-pds">"</span></span>}
  },
  <span class="pl-s"><span class="pl-pds">"</span>secrets<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>serviceCredential<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>source<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-k">&lt;</span>secret_name<span class="pl-k">&gt;</span>
    }
  }
}</pre></div>

<p>This causes Marathon to launch the task with the
<code>DCOS_SERVICE_ACCOUNT_CREDENTIAL</code> environment variable set to the
contents of the service account's private key.  The Mesos agent looks
for this environment variable and will inject it as the <code>secret</code> in
the scheduler's registration request.</p>

<h1>
<a id="http-api" class="anchor" href="#http-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HTTP API</h1>

<p>Services expose an HTTP API to support common operations.  There are
two ways to access this API.</p>

<p>The first is from clients running outside of DC/OS, such as from your
local machine.  These clients must authenticate.  For example:</p>

<div class="highlight highlight-source-shell"><pre>curl -H <span class="pl-s"><span class="pl-pds">"</span>Authorization: token=<span class="pl-s"><span class="pl-pds">$(</span>dcos config show core.dcos_acs_token<span class="pl-pds">)</span></span><span class="pl-pds">"</span></span> \
    <span class="pl-s"><span class="pl-pds">"</span><span class="pl-s"><span class="pl-pds">$(</span>dcos config show core.dcos_url<span class="pl-pds">)</span></span>/service/data-store/v1/plan/status<span class="pl-pds">"</span></span></pre></div>

<p>To learn more about DC/OS Authentication, visit the
<a href="https://dcos.io/docs/1.8/administration/id-and-access-%0Amgt/managing-authentication/">Managing
Authentication</a>
section of the DC/OS documentation.</p>

<p>The second way to access the HTTP API is from clients running inside
the
DC/OS cluster.  These clients may bypass DC/OS authentication and
access the scheduler directly:</p>

<div class="highlight highlight-source-shell"><pre>curl <span class="pl-s"><span class="pl-pds">"</span>data-store.marathon.mesos:&lt;port&gt;/v1/plan/status<span class="pl-pds">"</span></span></pre></div>

<p>Where  is the port you gave to the <code>DefaultService</code> constructor
in the <a href="#define-a-service">Define a Service</a> section.</p>

<p>Several API endpoints are listed in this tutorial and a full API is
forthcoming.</p>

<h1>
<a id="features-at-a-glance" class="anchor" href="#features-at-a-glance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features at-a-glance</h1>

<ul>
<li><p><strong>Simple service definitions</strong> - A simple, declarative API to
simplify resource offer configuration. <a href="#simple-service-definitions">Learn
more</a>.</p></li>
<li><p><strong>Multi-tier service support</strong> - A scheduler created with the DC/OS
Stateful Services SDK is aware of dependencies between tiers of
processes, enabling one-click install and safe failure recovery.
<a href="#multi-tier-service-support">Learn more</a>.</p></li>
<li><p><strong>Deployment strategies</strong> - The DC/OS Stateful Services SDK supports
diverse deployment strategies to fit the needs of schedulers. <a href="#deployment-strategies">Learn
more</a>.</p></li>
<li><p><strong>Configuration management</strong> - The DC/OS Stateful Services SDK can
read
configuration from an external source, detect configuration
modifications, and control which configurations can be modified by the
user. <a href="#configuration-management">Learn more</a>.</p></li>
<li><p><strong>Interactive upgrade support</strong> - You can pause, continue, or abort
an upgrade interactively in order to upgrade tasks safely. <a href="#interactive-upgrade-support">Learn
more</a>.</p></li>
<li><p><strong>Fault tolerance</strong> - Schedulers built with the SDK are
automatically configured to detect and
restart failed tasks on the same node (to preserve state) and, if the
node fails, restart it on a different node. <a href="#fault-tolerance">Learn
more</a>.</p></li>
<li><p><strong>Persistent volumes</strong> - The SDK automatically configures your
scheduler to
create persistent volumes, enabling stateful tasks. <a href="#persistent-volumes">Learn
more</a>.</p></li>
</ul>

<h1>
<a id="features-in-depth" class="anchor" href="#features-in-depth" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Features in-depth</h1>

<h2>
<a id="simple-service-definitions" class="anchor" href="#simple-service-definitions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple service definitions</h2>

<p>Mesos offers resources to the scheduler for launching tasks rather
than launching tasks against a fixed API. Resource offers are more
powerful and flexible than a declarative task launching API because
schedulers can apply arbitrary logic to determine the set of resources
they consume.</p>

<p>However, the majority of schedulers, especially schedulers for
stateful services, only need a basic API. For these cases,
declarative APIs are much simpler.  A simple scheduler only needs to
run N containers with M memory and C cpu, along with some set of
persistent volumes, ports, etc.</p>

<p>For these cases, the DC/OS Stateful Services SDK provides a simple,
declarative
API built on top of Mesos resource offers. You define your service
declaratively and the SDK manages installing and supervising the
service using resource offers from Mesos.</p>

<p>You can think of this as doing for stateful services what Marathon
does for stateless services, while still allowing you to drop down to
lower layers when you need more flexibility.</p>

<h2>
<a id="multi-tier-service-support" class="anchor" href="#multi-tier-service-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multi-tier service support</h2>

<p>Many stateful services have multiple interdependent tiers,
each running different processes.  For example, Apache HDFS is
composed of NameNodes, JournalNodes, and DataNodes. JournalNodes start
before NameNodes, which start before DataNodes.  To support one-click
install for users, as well as safe recovery from failures, the
scheduler must be aware of these dependencies.</p>

<h2>
<a id="deployment-strategies" class="anchor" href="#deployment-strategies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deployment strategies</h2>

<p>Many stateful services have strict deployment requirements.  Some,
including, for instance Apache Cassandra, require nodes to be added to
the cluster one at at time.  Others may permit parallel deployment.
The DC/OS Stateful Services SDK includes deployment strategies
that support these different requirements.</p>

<h2>
<a id="configuration-management" class="anchor" href="#configuration-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration management</h2>

<p>For any framework, at least two components must be configured: the
scheduler and the service.  Scheduler configuration includes things
like node count, deployment strategies, and security parameters.
Service configuration includes resource settings such memory, CPU, and
ports, as well as any configuration passed on to the underlying
service.</p>

<p>The DC/OS Stateful Services SDK includes logic for reading
configuration from an external source (default: environment
variables), detecting changes to the configuration, and redeploying
any affected tasks.  It also supports marking certain configuration
parameters as "unmodifiable," so that the user can't change them after
install time.  For example, the disk size of permanent volumes cannot
be modified because volume size is static.</p>

<h2>
<a id="interactive-upgrade-support" class="anchor" href="#interactive-upgrade-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interactive upgrade support</h2>

<p>Tasks must often be updated one at a time, and often depend on certain
administrative tasks like backup/restore.  You can choose to pause,
continue, or abort an upgrade interactively.</p>

<h2>
<a id="fault-tolerance" class="anchor" href="#fault-tolerance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fault tolerance</h2>

<p>There are two component failures that any scheduler must defend
against: the scheduler and the service. The SDK sets up fault
tolerance for your scheduler automatically.</p>

<p>The SDK abstracts away task reconciliation with the Mesos master in
the case of task failure. In the case of service failure, the SDK
configures your scheduler to restart the task on the same node or, if
the node has failed, restarts the task on a different node. The
scheduler's persistent volume is reused on restart. A new persistent
volume is created when a node fails.</p>

<p>The mechanism to determine whether a task has permanently failed is time-based by default.
When a task stays in a terminal state for some
configurable duration, it is determined to have failed. The default
duration is 20 minutes.  Once tasks have been determined to have
permanently failed, a second configurable parameter determines how many 
destructive task replacements may occur in a given time period.  By 
default, no more than one task may be destructively replaced in any 10 
minute period.  Finally, automatic destructive recovery may be entirely
suppressed.</p>

<p>Consider the simplest construct for the <code>DefaultScheduler</code>, in which
automatic destructive recovery configuration is exposed:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">DefaultScheduler</span> create(
        <span class="pl-smi">String</span> frameworkName,
        <span class="pl-smi">PlanManager</span> deploymentPlanManager,
        <span class="pl-k">Optional&lt;<span class="pl-smi">Integer</span>&gt;</span> permanentFailureTimeoutSec,
        <span class="pl-smi">Integer</span> destructiveRecoveryDelaySec) {</pre></div>

<p>The <code>permanentFailureTimeoutSec</code> argument determines how long a task
must be in a terminal state before it is considered permanently failed.
If no value is present, automatic destructive recovery is turned off.</p>

<p>The <code>destructiveRecoveryDelaySec</code> argument determines how much time must
pass between destructive task replacement events.</p>

<p>The parameters above are one implementation of a more general
permanent task recovery scheme.  The task recovery scheme has two major components: a <em>safety
constraint</em> and a <em>performance constraint</em>.  In the example above, the
duration that must be waited until a task is considered permanently 
failed is the <em>safety constraint</em>. You can write a safety constraint that is more complex than a simple timeout.</p>

<p>In the example above, the recovery delay
parameter is the <em>performance constraint</em>.  Even if a large number of tasks could be safely
destructively replaced, it could cause performance degradation
as network traffic increases to reconstruct lost task state. In addition, you must be cautious when automating destructive recovery operations, so it is prudent to throttle the maximum rate of
destruction.</p>

<p>Recovery, like deployment, is mediated by a plan. Use the endpoint below to view the status of the plan.</p>

<div class="highlight highlight-source-shell"><pre>GET /v1/plans/recovery</pre></div>

<p>If no failures of any kind have occurred, you will see output similar to the snippet below.</p>

<div class="highlight highlight-source-json"><pre>{
    <span class="pl-ii">phases</span>: [{
        <span class="pl-ii">id</span>: <span class="pl-s"><span class="pl-pds">"</span>128d7df9-8605-4e1a-b98b-478821b1aeda<span class="pl-pds">"</span></span>,
        <span class="pl-ii">name</span>: <span class="pl-s"><span class="pl-pds">"</span>recovery<span class="pl-pds">"</span></span>,
        <span class="pl-ii">steps</span>: [],
        <span class="pl-ii">status</span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
    }],
    <span class="pl-ii">errors</span>: [],
    <span class="pl-ii">status</span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
}</pre></div>

<p>If a task has crashed and been recovered, you will see a plan similar
to:</p>

<div class="highlight highlight-source-json"><pre>{
    <span class="pl-ii">phases</span>: [{
        <span class="pl-ii">id</span>: <span class="pl-s"><span class="pl-pds">"</span>88d944d3-4fc2-4605-889f-96b5429fb8af<span class="pl-pds">"</span></span>,
        <span class="pl-ii">name</span>: <span class="pl-s"><span class="pl-pds">"</span>recovery<span class="pl-pds">"</span></span>,
        <span class="pl-ii">steps</span>: [{
            <span class="pl-ii">id</span>: <span class="pl-s"><span class="pl-pds">"</span>ed4d2209-ab19-4242-b7da-d10cdf9e443b<span class="pl-pds">"</span></span>,
            <span class="pl-ii">status</span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>,
            <span class="pl-ii">name</span>: <span class="pl-s"><span class="pl-pds">"</span>data-2<span class="pl-pds">"</span></span>,
            <span class="pl-ii">message</span>: <span class="pl-s"><span class="pl-pds">"</span>org.apache.mesos.scheduler.recovery.DefaultRecoveryBlock: 'data-2 [ed4d2209-ab19-4242-b7da-d10cdf9e443b]' has status: 'COMPLETE'. RecoveryType: TRANSIENT<span class="pl-pds">"</span></span>
        }],
        <span class="pl-ii">status</span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
    }],
    <span class="pl-ii">errors</span>: [],
    <span class="pl-ii">status</span>: <span class="pl-s"><span class="pl-pds">"</span>COMPLETE<span class="pl-pds">"</span></span>
}</pre></div>

<p>Note in particular the message that contains
<code>RecoveryType: TRANSIENT</code> for the step named <code>data-2</code>.  This message indicates a
recovery from a temporary failure.  The task was able to be successfully
recovered in its previous location with all its old resources, including
persistent volumes.  In the case of a permanent failure recovery, the
message would instead contain <code>RecoveryType: PERMANENT</code>.</p>

<h2>
<a id="persistent-volumes" class="anchor" href="#persistent-volumes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Persistent volumes</h2>

<p>Schedulers must create persistent volumes that will
live beyond the life a single task to tolerate failure, and they must
reserve these volumes to prevent other frameworks from taking them.
The SDK configures persistent volumes for your scheduler automatically.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mesosphere">mesosphere</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
